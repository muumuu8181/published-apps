<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>データ構造・アルゴリズム可視化ツール</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2563eb;
            --secondary-color: #1d4ed8;
            --accent-color: #3b82f6;
            --background-color: #f8fafc;
            --surface-color: #ffffff;
            --text-color: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        [data-theme="dark"] {
            --background-color: #0f172a;
            --surface-color: #1e293b;
            --text-color: #f8fafc;
            --text-secondary: #cbd5e1;
            --border-color: #334155;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px 0;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            color: white;
            border-radius: 16px;
            box-shadow: var(--shadow-lg);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background-color: var(--surface-color);
            border-radius: 12px;
            padding: 8px;
            box-shadow: var(--shadow-md);
            overflow-x: auto;
        }

        .tab-button {
            padding: 12px 24px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            white-space: nowrap;
            min-width: 120px;
        }

        .tab-button:hover {
            background-color: var(--primary-color);
            color: white;
        }

        .tab-button.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: var(--shadow-sm);
        }

        .tab-content {
            display: none;
            background-color: var(--surface-color);
            border-radius: 16px;
            padding: 30px;
            box-shadow: var(--shadow-md);
            min-height: 600px;
        }

        .tab-content.active {
            display: block;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background-color: var(--background-color);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .control-input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--surface-color);
            color: var(--text-color);
            font-size: 0.9rem;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: var(--text-secondary);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--text-color);
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }

        .visualization-area {
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .data-structure-canvas {
            width: 100%;
            height: 400px;
            background: linear-gradient(45deg, #f0f9ff 25%, transparent 25%),
                        linear-gradient(-45deg, #f0f9ff 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, #f0f9ff 75%),
                        linear-gradient(-45deg, transparent 75%, #f0f9ff 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .array-element {
            display: inline-block;
            width: 60px;
            height: 60px;
            border: 2px solid var(--primary-color);
            background-color: var(--surface-color);
            margin: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 8px;
            transition: all 0.3s ease;
            position: relative;
        }

        .array-element.active {
            background-color: var(--primary-color);
            color: white;
            transform: scale(1.1);
        }

        .array-element.comparing {
            border-color: var(--warning-color);
            background-color: var(--warning-color);
            color: white;
        }

        .array-element.sorted {
            border-color: var(--success-color);
            background-color: var(--success-color);
            color: white;
        }

        .array-index {
            position: absolute;
            top: -25px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .node {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: absolute;
            transition: all 0.5s ease;
        }

        .node.visited {
            background-color: var(--success-color);
        }

        .node.current {
            background-color: var(--warning-color);
            transform: scale(1.2);
        }

        .edge {
            position: absolute;
            background-color: var(--text-secondary);
            transform-origin: left center;
            transition: all 0.3s ease;
        }

        .edge.active {
            background-color: var(--primary-color);
            height: 4px !important;
        }

        .stats-panel {
            background-color: var(--background-color);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background-color: var(--surface-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .explanation-panel {
            background-color: var(--background-color);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid var(--primary-color);
        }

        .code-block {
            background-color: #1e293b;
            color: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-slider {
            width: 150px;
        }

        .algorithm-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .algorithm-card {
            padding: 20px;
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .algorithm-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .algorithm-card.selected {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
            color: white;
        }

        .complexity-badge {
            display: inline-block;
            background-color: var(--accent-color);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-top: 5px;
        }

        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
        }

        .log-output {
            background-color: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 15px;
            border-radius: 8px;
            height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            border: 1px solid var(--border-color);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--primary-color);
            transition: width 0.3s ease;
            width: 0%;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .nav-tabs {
                overflow-x: auto;
            }
            
            .tab-content {
                padding: 20px;
            }
            
            .control-panel {
                flex-direction: column;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .pulse {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="theme-toggle" onclick="toggleTheme()" title="テーマ切り替え">
        🌓
    </div>

    <div class="container">
        <div class="header fade-in">
            <h1>データ構造・アルゴリズム可視化ツール</h1>
            <p>プログラミングの基礎概念を視覚的に学習しよう</p>
        </div>

        <div class="nav-tabs">
            <button class="tab-button active" onclick="showTab('data-structures')">データ構造</button>
            <button class="tab-button" onclick="showTab('sorting')">ソートアルゴリズム</button>
            <button class="tab-button" onclick="showTab('searching')">探索アルゴリズム</button>
            <button class="tab-button" onclick="showTab('graphs')">グラフアルゴリズム</button>
        </div>

        <!-- データ構造タブ -->
        <div id="data-structures" class="tab-content active">
            <h2>データ構造の可視化</h2>
            
            <div class="algorithm-selector">
                <div class="algorithm-card selected" onclick="selectDataStructure('array')">
                    <h3>配列 (Array)</h3>
                    <div class="complexity-badge">O(1) アクセス</div>
                </div>
                <div class="algorithm-card" onclick="selectDataStructure('linkedlist')">
                    <h3>連結リスト</h3>
                    <div class="complexity-badge">O(n) 探索</div>
                </div>
                <div class="algorithm-card" onclick="selectDataStructure('stack')">
                    <h3>スタック</h3>
                    <div class="complexity-badge">O(1) Push/Pop</div>
                </div>
                <div class="algorithm-card" onclick="selectDataStructure('queue')">
                    <h3>キュー</h3>
                    <div class="complexity-badge">O(1) Enqueue/Dequeue</div>
                </div>
                <div class="algorithm-card" onclick="selectDataStructure('binarytree')">
                    <h3>二分木</h3>
                    <div class="complexity-badge">O(log n) 探索</div>
                </div>
                <div class="algorithm-card" onclick="selectDataStructure('hashtable')">
                    <h3>ハッシュテーブル</h3>
                    <div class="complexity-badge">O(1) 平均</div>
                </div>
            </div>

            <div class="control-panel">
                <div class="control-group">
                    <label>データ入力</label>
                    <input type="text" id="dataInput" class="control-input" placeholder="例: 5,3,8,1,9" value="5,3,8,1,9,2,7,4,6">
                </div>
                <div class="control-group">
                    <label>操作</label>
                    <select id="operationSelect" class="control-input">
                        <option value="insert">挿入</option>
                        <option value="delete">削除</option>
                        <option value="search">検索</option>
                        <option value="traverse">走査</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>値</label>
                    <input type="number" id="operationValue" class="control-input" placeholder="値" value="10">
                </div>
                <button class="btn btn-primary" onclick="executeDataStructureOperation()">実行</button>
                <button class="btn btn-secondary" onclick="resetDataStructure()">リセット</button>
            </div>

            <div class="visualization-area">
                <canvas id="dataStructureCanvas" class="data-structure-canvas"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="dsOperations">0</div>
                        <div class="stat-label">操作回数</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="dsElements">0</div>
                        <div class="stat-label">要素数</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="dsTimeComplexity">O(1)</div>
                        <div class="stat-label">時間計算量</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="dsSpaceComplexity">O(n)</div>
                        <div class="stat-label">空間計算量</div>
                    </div>
                </div>
            </div>

            <div class="explanation-panel">
                <h3 id="dsExplanationTitle">配列 (Array)</h3>
                <p id="dsExplanationText">配列は同じ型のデータを連続したメモリ領域に格納するデータ構造です。インデックスによる高速なアクセスが特徴です。</p>
                <div class="code-block" id="dsCodeBlock">
<pre>// 配列の基本操作
let arr = [5, 3, 8, 1, 9];

// アクセス: O(1)
console.log(arr[2]); // 8

// 挿入: O(n) - 末尾は O(1)
arr.push(10); // [5, 3, 8, 1, 9, 10]

// 削除: O(n) - 末尾は O(1)  
arr.pop(); // [5, 3, 8, 1, 9]</pre>
                </div>
            </div>
        </div>

        <!-- ソートアルゴリズムタブ -->
        <div id="sorting" class="tab-content">
            <h2>ソートアルゴリズムの可視化</h2>
            
            <div class="algorithm-selector">
                <div class="algorithm-card selected" onclick="selectSortAlgorithm('bubble')">
                    <h3>バブルソート</h3>
                    <div class="complexity-badge">O(n²)</div>
                </div>
                <div class="algorithm-card" onclick="selectSortAlgorithm('selection')">
                    <h3>選択ソート</h3>
                    <div class="complexity-badge">O(n²)</div>
                </div>
                <div class="algorithm-card" onclick="selectSortAlgorithm('insertion')">
                    <h3>挿入ソート</h3>
                    <div class="complexity-badge">O(n²)</div>
                </div>
                <div class="algorithm-card" onclick="selectSortAlgorithm('merge')">
                    <h3>マージソート</h3>
                    <div class="complexity-badge">O(n log n)</div>
                </div>
                <div class="algorithm-card" onclick="selectSortAlgorithm('quick')">
                    <h3>クイックソート</h3>
                    <div class="complexity-badge">O(n log n)</div>
                </div>
                <div class="algorithm-card" onclick="selectSortAlgorithm('heap')">
                    <h3>ヒープソート</h3>
                    <div class="complexity-badge">O(n log n)</div>
                </div>
            </div>

            <div class="control-panel">
                <div class="control-group">
                    <label>配列サイズ</label>
                    <input type="range" id="arraySizeSlider" class="control-input" min="5" max="50" value="15" onchange="generateRandomArray()">
                    <span id="arraySizeValue">15</span>
                </div>
                <div class="speed-control">
                    <label>実行速度</label>
                    <input type="range" id="speedSlider" class="speed-slider" min="1" max="10" value="5">
                    <span>高速 ←→ 低速</span>
                </div>
                <button class="btn btn-primary" onclick="startSorting()">ソート開始</button>
                <button class="btn btn-secondary" onclick="pauseSorting()">一時停止</button>
                <button class="btn btn-warning" onclick="stepSort()">ステップ実行</button>
                <button class="btn btn-secondary" onclick="generateRandomArray()">配列生成</button>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="sortProgress"></div>
            </div>

            <div class="visualization-area">
                <div id="sortVisualization"></div>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="comparisons">0</div>
                        <div class="stat-label">比較回数</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="swaps">0</div>
                        <div class="stat-label">交換回数</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="arrayAccesses">0</div>
                        <div class="stat-label">配列アクセス</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="timeElapsed">0ms</div>
                        <div class="stat-label">実行時間</div>
                    </div>
                </div>
            </div>

            <div class="explanation-panel">
                <h3 id="sortExplanationTitle">バブルソート</h3>
                <p id="sortExplanationText">隣接する要素を比較し、順序が間違っていれば交換を繰り返すソートアルゴリズムです。</p>
                <div class="code-block" id="sortCodeBlock">
<pre>function bubbleSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交換
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}</pre>
                </div>
            </div>
        </div>

        <!-- 探索アルゴリズムタブ -->
        <div id="searching" class="tab-content">
            <h2>探索アルゴリズムの可視化</h2>
            
            <div class="algorithm-selector">
                <div class="algorithm-card selected" onclick="selectSearchAlgorithm('linear')">
                    <h3>線形探索</h3>
                    <div class="complexity-badge">O(n)</div>
                </div>
                <div class="algorithm-card" onclick="selectSearchAlgorithm('binary')">
                    <h3>二分探索</h3>
                    <div class="complexity-badge">O(log n)</div>
                </div>
                <div class="algorithm-card" onclick="selectSearchAlgorithm('jump')">
                    <h3>ジャンプ探索</h3>
                    <div class="complexity-badge">O(√n)</div>
                </div>
                <div class="algorithm-card" onclick="selectSearchAlgorithm('interpolation')">
                    <h3>補間探索</h3>
                    <div class="complexity-badge">O(log log n)</div>
                </div>
            </div>

            <div class="control-panel">
                <div class="control-group">
                    <label>配列データ</label>
                    <input type="text" id="searchArrayInput" class="control-input" placeholder="ソート済み配列" value="1,3,5,7,9,11,13,15,17,19,21,23,25,27,29">
                </div>
                <div class="control-group">
                    <label>検索値</label>
                    <input type="number" id="searchValue" class="control-input" placeholder="検索したい値" value="15">
                </div>
                <button class="btn btn-primary" onclick="startSearch()">探索開始</button>
                <button class="btn btn-secondary" onclick="resetSearch()">リセット</button>
                <button class="btn btn-warning" onclick="generateSortedArray()">ソート済み配列生成</button>
            </div>

            <div class="visualization-area">
                <div id="searchVisualization"></div>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="searchComparisons">0</div>
                        <div class="stat-label">比較回数</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="searchSteps">0</div>
                        <div class="stat-label">ステップ数</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="searchResult">未実行</div>
                        <div class="stat-label">結果</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="searchTime">0ms</div>
                        <div class="stat-label">実行時間</div>
                    </div>
                </div>
            </div>

            <div class="explanation-panel">
                <h3 id="searchExplanationTitle">線形探索</h3>
                <p id="searchExplanationText">配列の最初から順番に要素を確認していく最も基本的な探索アルゴリズムです。</p>
                <div class="code-block" id="searchCodeBlock">
<pre>function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // 見つかった位置を返す
        }
    }
    return -1; // 見つからない場合
}</pre>
                </div>
            </div>
        </div>

        <!-- グラフアルゴリズムタブ -->
        <div id="graphs" class="tab-content">
            <h2>グラフアルゴリズムの可視化</h2>
            
            <div class="algorithm-selector">
                <div class="algorithm-card selected" onclick="selectGraphAlgorithm('dfs')">
                    <h3>深さ優先探索</h3>
                    <div class="complexity-badge">O(V + E)</div>
                </div>
                <div class="algorithm-card" onclick="selectGraphAlgorithm('bfs')">
                    <h3>幅優先探索</h3>
                    <div class="complexity-badge">O(V + E)</div>
                </div>
                <div class="algorithm-card" onclick="selectGraphAlgorithm('dijkstra')">
                    <h3>ダイクストラ法</h3>
                    <div class="complexity-badge">O(V²)</div>
                </div>
                <div class="algorithm-card" onclick="selectGraphAlgorithm('astar')">
                    <h3>A*アルゴリズム</h3>
                    <div class="complexity-badge">O(b^d)</div>
                </div>
            </div>

            <div class="control-panel">
                <div class="control-group">
                    <label>グラフタイプ</label>
                    <select id="graphType" class="control-input">
                        <option value="grid">グリッド</option>
                        <option value="tree">ツリー</option>
                        <option value="random">ランダム</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>開始ノード</label>
                    <input type="number" id="startNode" class="control-input" value="0" min="0" max="24">
                </div>
                <div class="control-group">
                    <label>終了ノード</label>
                    <input type="number" id="endNode" class="control-input" value="24" min="0" max="24">
                </div>
                <button class="btn btn-primary" onclick="startGraphTraversal()">探索開始</button>
                <button class="btn btn-secondary" onclick="resetGraph()">リセット</button>
                <button class="btn btn-warning" onclick="generateGraph()">グラフ生成</button>
            </div>

            <div class="visualization-area">
                <canvas id="graphCanvas" class="data-structure-canvas"></canvas>
            </div>

            <div class="stats-panel">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="visitedNodes">0</div>
                        <div class="stat-label">訪問ノード数</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="pathLength">0</div>
                        <div class="stat-label">パス長</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="graphTime">0ms</div>
                        <div class="stat-label">実行時間</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="efficiency">0%</div>
                        <div class="stat-label">効率性</div>
                    </div>
                </div>
            </div>

            <div class="explanation-panel">
                <h3 id="graphExplanationTitle">深さ優先探索 (DFS)</h3>
                <p id="graphExplanationText">可能な限り深く探索してから、次の分岐を探索するアルゴリズムです。スタックまたは再帰を使用します。</p>
                <div class="code-block" id="graphCodeBlock">
<pre>function dfs(graph, start, visited = new Set()) {
    visited.add(start);
    console.log(start);
    
    for (let neighbor of graph[start]) {
        if (!visited.has(neighbor)) {
            dfs(graph, neighbor, visited);
        }
    }
}</pre>
                </div>
            </div>
        </div>

        <div class="log-output" id="logOutput">
システム準備完了
データ構造・アルゴリズム可視化ツール v1.0.0 起動
ログ記録開始: <span id="currentTime"></span>
        </div>
    </div>

    <script>
        // グローバル変数
        let currentTab = 'data-structures';
        let currentDataStructure = 'array';
        let currentSortAlgorithm = 'bubble';
        let currentSearchAlgorithm = 'linear';
        let currentGraphAlgorithm = 'dfs';
        let isAnimating = false;
        let animationSpeed = 500;
        
        // 統計データ
        let stats = {
            operations: 0,
            comparisons: 0,
            swaps: 0,
            arrayAccesses: 0,
            elements: 0,
            visitedNodes: 0
        };

        // データ保存用
        let dataStructureData = [5, 3, 8, 1, 9, 2, 7, 4, 6];
        let sortingArray = [];
        let searchArray = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29];
        let graph = [];
        let graphNodes = [];

        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            updateCurrentTime();
            initializeDataStructure();
            generateRandomArray();
            generateGraph();
            logMessage('アプリケーション初期化完了');
            
            // 定期的に時刻更新
            setInterval(updateCurrentTime, 1000);
        });

        function updateCurrentTime() {
            const now = new Date();
            document.getElementById('currentTime').textContent = now.toLocaleString('ja-JP');
        }

        function logMessage(message) {
            const logOutput = document.getElementById('logOutput');
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            logOutput.innerHTML += `\n[${timestamp}] ${message}`;
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        // テーマ切り替え
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            body.setAttribute('data-theme', newTheme);
            logMessage(`テーマを${newTheme}モードに変更`);
        }

        // タブ切り替え
        function showTab(tabName) {
            // 全てのタブを非表示
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 全てのタブボタンを非アクティブ
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 選択されたタブを表示
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            currentTab = tabName;
            logMessage(`${tabName}タブに切り替え`);
        }

        // データ構造選択
        function selectDataStructure(dsType) {
            document.querySelectorAll('#data-structures .algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.algorithm-card').classList.add('selected');
            
            currentDataStructure = dsType;
            updateDataStructureExplanation(dsType);
            initializeDataStructure();
            logMessage(`データ構造: ${dsType}を選択`);
        }

        // データ構造の説明更新
        function updateDataStructureExplanation(dsType) {
            const explanations = {
                array: {
                    title: '配列 (Array)',
                    text: '配列は同じ型のデータを連続したメモリ領域に格納するデータ構造です。インデックスによる高速なアクセスが特徴です。',
                    code: `// 配列の基本操作
let arr = [5, 3, 8, 1, 9];

// アクセス: O(1)
console.log(arr[2]); // 8

// 挿入: O(n) - 末尾は O(1)
arr.push(10);

// 削除: O(n) - 末尾は O(1)  
arr.pop();`
                },
                linkedlist: {
                    title: '連結リスト (Linked List)',
                    text: '各ノードがデータと次のノードへの参照を持つデータ構造です。動的なサイズ変更が可能です。',
                    code: `// 連結リストのノード
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// 挿入: O(1) - 先頭に挿入
// 探索: O(n)
// 削除: O(n)`
                },
                stack: {
                    title: 'スタック (Stack)',
                    text: 'LIFO（Last In, First Out）の原則に従うデータ構造です。最後に追加された要素が最初に削除されます。',
                    code: `class Stack {
    constructor() {
        this.items = [];
    }
    
    push(item) { // O(1)
        this.items.push(item);
    }
    
    pop() { // O(1)
        return this.items.pop();
    }
}`
                },
                queue: {
                    title: 'キュー (Queue)',
                    text: 'FIFO（First In, First Out）の原則に従うデータ構造です。最初に追加された要素が最初に削除されます。',
                    code: `class Queue {
    constructor() {
        this.items = [];
    }
    
    enqueue(item) { // O(1)
        this.items.push(item);
    }
    
    dequeue() { // O(1)
        return this.items.shift();
    }
}`
                },
                binarytree: {
                    title: '二分木 (Binary Tree)',
                    text: '各ノードが最大2つの子ノードを持つ木構造です。二分探索木では効率的な探索が可能です。',
                    code: `class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

// 探索: O(log n) - 平均
// 挿入: O(log n) - 平均
// 削除: O(log n) - 平均`
                },
                hashtable: {
                    title: 'ハッシュテーブル (Hash Table)',
                    text: 'ハッシュ関数を使用してキーを配列のインデックスにマップするデータ構造です。高速な検索が可能です。',
                    code: `class HashTable {
    constructor(size = 10) {
        this.size = size;
        this.table = new Array(size);
    }
    
    hash(key) {
        return key % this.size;
    }
    
    set(key, value) { // O(1) 平均
        const index = this.hash(key);
        this.table[index] = value;
    }
}`
                }
            };

            const explanation = explanations[dsType];
            document.getElementById('dsExplanationTitle').textContent = explanation.title;
            document.getElementById('dsExplanationText').textContent = explanation.text;
            document.getElementById('dsCodeBlock').innerHTML = `<pre>${explanation.code}</pre>`;
        }

        // データ構造初期化
        function initializeDataStructure() {
            stats.elements = dataStructureData.length;
            updateDataStructureStats();
            drawDataStructure();
        }

        // データ構造の描画
        function drawDataStructure() {
            const canvas = document.getElementById('dataStructureCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            switch(currentDataStructure) {
                case 'array':
                    drawArray(ctx);
                    break;
                case 'linkedlist':
                    drawLinkedList(ctx);
                    break;
                case 'stack':
                    drawStack(ctx);
                    break;
                case 'queue':
                    drawQueue(ctx);
                    break;
                case 'binarytree':
                    drawBinaryTree(ctx);
                    break;
                case 'hashtable':
                    drawHashTable(ctx);
                    break;
            }
        }

        function drawArray(ctx) {
            const elementWidth = 60;
            const elementHeight = 60;
            const startX = 50;
            const startY = canvas.height / 2 - elementHeight / 2;
            
            dataStructureData.forEach((value, index) => {
                const x = startX + index * (elementWidth + 10);
                const y = startY;
                
                // 要素の描画
                ctx.fillStyle = '#3b82f6';
                ctx.fillRect(x, y, elementWidth, elementHeight);
                
                // 枠線
                ctx.strokeStyle = '#1d4ed8';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, elementWidth, elementHeight);
                
                // 値の描画
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x + elementWidth/2, y + elementHeight/2 + 6);
                
                // インデックスの描画
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px Arial';
                ctx.fillText(index, x + elementWidth/2, y - 10);
            });
        }

        function drawLinkedList(ctx) {
            const nodeSize = 50;
            const nodeSpacing = 100;
            const startX = 50;
            const startY = canvas.height / 2;
            
            dataStructureData.forEach((value, index) => {
                const x = startX + index * nodeSpacing;
                const y = startY;
                
                // ノードの描画
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(x, y, nodeSize/2, 0, 2 * Math.PI);
                ctx.fill();
                
                // 値の描画
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x, y + 5);
                
                // 矢印の描画
                if (index < dataStructureData.length - 1) {
                    ctx.strokeStyle = '#1d4ed8';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + nodeSize/2, y);
                    ctx.lineTo(x + nodeSpacing - nodeSize/2, y);
                    ctx.stroke();
                    
                    // 矢印の頭部
                    ctx.beginPath();
                    ctx.moveTo(x + nodeSpacing - nodeSize/2 - 10, y - 5);
                    ctx.lineTo(x + nodeSpacing - nodeSize/2, y);
                    ctx.lineTo(x + nodeSpacing - nodeSize/2 - 10, y + 5);
                    ctx.stroke();
                }
            });
        }

        function drawStack(ctx) {
            const elementWidth = 80;
            const elementHeight = 40;
            const startX = canvas.width / 2 - elementWidth / 2;
            const startY = canvas.height - 50;
            
            dataStructureData.forEach((value, index) => {
                const x = startX;
                const y = startY - index * (elementHeight + 5);
                
                // 要素の描画
                ctx.fillStyle = index === dataStructureData.length - 1 ? '#f59e0b' : '#3b82f6';
                ctx.fillRect(x, y, elementWidth, elementHeight);
                
                // 枠線
                ctx.strokeStyle = '#1d4ed8';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, elementWidth, elementHeight);
                
                // 値の描画
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x + elementWidth/2, y + elementHeight/2 + 6);
            });
            
            // TOPラベル
            if (dataStructureData.length > 0) {
                ctx.fillStyle = '#f59e0b';
                ctx.font = 'bold 14px Arial';
                ctx.fillText('TOP', startX + elementWidth + 20, startY - (dataStructureData.length - 1) * (elementHeight + 5) + elementHeight/2);
            }
        }

        function drawQueue(ctx) {
            const elementWidth = 60;
            const elementHeight = 60;
            const startX = 50;
            const startY = canvas.height / 2 - elementHeight / 2;
            
            dataStructureData.forEach((value, index) => {
                const x = startX + index * (elementWidth + 10);
                const y = startY;
                
                // 要素の描画
                let fillColor = '#3b82f6';
                if (index === 0) fillColor = '#10b981'; // FRONT
                if (index === dataStructureData.length - 1) fillColor = '#f59e0b'; // REAR
                
                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, elementWidth, elementHeight);
                
                // 枠線
                ctx.strokeStyle = '#1d4ed8';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, elementWidth, elementHeight);
                
                // 値の描画
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x + elementWidth/2, y + elementHeight/2 + 6);
            });
            
            // FRONTとREARラベル
            if (dataStructureData.length > 0) {
                ctx.fillStyle = '#10b981';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('FRONT', startX + elementWidth/2, startY - 15);
                
                ctx.fillStyle = '#f59e0b';
                ctx.fillText('REAR', startX + (dataStructureData.length - 1) * (elementWidth + 10) + elementWidth/2, startY - 15);
            }
        }

        function drawBinaryTree(ctx) {
            if (dataStructureData.length === 0) return;
            
            const nodeSize = 40;
            const levelHeight = 80;
            const rootX = canvas.width / 2;
            const rootY = 80;
            
            function drawNode(value, x, y, level) {
                // ノードの描画
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(x, y, nodeSize/2, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#1d4ed8';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 値の描画
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(value, x, y + 5);
            }
            
            // 簡単な二分木の描画（完全二分木として）
            dataStructureData.forEach((value, index) => {
                const level = Math.floor(Math.log2(index + 1));
                const positionInLevel = index - (Math.pow(2, level) - 1);
                const nodesInLevel = Math.pow(2, level);
                const spacing = canvas.width / (nodesInLevel + 1);
                
                const x = spacing * (positionInLevel + 1);
                const y = rootY + level * levelHeight;
                
                drawNode(value, x, y, level);
                
                // 親ノードへの線を描画
                if (index > 0) {
                    const parentIndex = Math.floor((index - 1) / 2);
                    const parentLevel = Math.floor(Math.log2(parentIndex + 1));
                    const parentPositionInLevel = parentIndex - (Math.pow(2, parentLevel) - 1);
                    const parentNodesInLevel = Math.pow(2, parentLevel);
                    const parentSpacing = canvas.width / (parentNodesInLevel + 1);
                    
                    const parentX = parentSpacing * (parentPositionInLevel + 1);
                    const parentY = rootY + parentLevel * levelHeight;
                    
                    ctx.strokeStyle = '#6b7280';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(parentX, parentY + nodeSize/2);
                    ctx.lineTo(x, y - nodeSize/2);
                    ctx.stroke();
                }
            });
        }

        function drawHashTable(ctx) {
            const bucketWidth = 80;
            const bucketHeight = 50;
            const bucketsPerRow = 5;
            const startX = 50;
            const startY = 50;
            
            // ハッシュテーブルのバケット数を10とする
            for (let i = 0; i < 10; i++) {
                const row = Math.floor(i / bucketsPerRow);
                const col = i % bucketsPerRow;
                const x = startX + col * (bucketWidth + 10);
                const y = startY + row * (bucketHeight + 30);
                
                // バケットの描画
                ctx.fillStyle = '#f3f4f6';
                ctx.fillRect(x, y, bucketWidth, bucketHeight);
                
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, bucketWidth, bucketHeight);
                
                // バケット番号
                ctx.fillStyle = '#374151';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(i, x + bucketWidth/2, y - 5);
                
                // バケット内のデータ（簡単なハッシュ関数を使用）
                const hashedValues = dataStructureData.filter(val => val % 10 === i);
                if (hashedValues.length > 0) {
                    ctx.fillStyle = '#3b82f6';
                    ctx.fillRect(x + 5, y + 5, bucketWidth - 10, bucketHeight - 10);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(hashedValues[0], x + bucketWidth/2, y + bucketHeight/2 + 5);
                    
                    if (hashedValues.length > 1) {
                        ctx.fillStyle = '#ef4444';
                        ctx.font = '10px Arial';
                        ctx.fillText(`+${hashedValues.length - 1}`, x + bucketWidth - 15, y + 15);
                    }
                }
            }
        }

        // データ構造操作実行
        function executeDataStructureOperation() {
            const operation = document.getElementById('operationSelect').value;
            const value = parseInt(document.getElementById('operationValue').value);
            
            stats.operations++;
            
            switch(operation) {
                case 'insert':
                    dataStructureData.push(value);
                    logMessage(`値 ${value} を挿入`);
                    break;
                case 'delete':
                    const index = dataStructureData.indexOf(value);
                    if (index !== -1) {
                        dataStructureData.splice(index, 1);
                        logMessage(`値 ${value} を削除`);
                    } else {
                        logMessage(`値 ${value} が見つかりません`);
                    }
                    break;
                case 'search':
                    const found = dataStructureData.indexOf(value);
                    if (found !== -1) {
                        logMessage(`値 ${value} がインデックス ${found} で見つかりました`);
                    } else {
                        logMessage(`値 ${value} が見つかりません`);
                    }
                    break;
                case 'traverse':
                    logMessage(`全要素: [${dataStructureData.join(', ')}]`);
                    break;
            }
            
            stats.elements = dataStructureData.length;
            updateDataStructureStats();
            drawDataStructure();
        }

        // データ構造リセット
        function resetDataStructure() {
            const input = document.getElementById('dataInput').value;
            dataStructureData = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
            stats.operations = 0;
            stats.elements = dataStructureData.length;
            updateDataStructureStats();
            drawDataStructure();
            logMessage('データ構造をリセット');
        }

        // データ構造統計更新
        function updateDataStructureStats() {
            document.getElementById('dsOperations').textContent = stats.operations;
            document.getElementById('dsElements').textContent = stats.elements;
            
            // 時間計算量の設定
            const complexities = {
                array: 'O(1)',
                linkedlist: 'O(n)',
                stack: 'O(1)',
                queue: 'O(1)',
                binarytree: 'O(log n)',
                hashtable: 'O(1)'
            };
            document.getElementById('dsTimeComplexity').textContent = complexities[currentDataStructure];
            document.getElementById('dsSpaceComplexity').textContent = 'O(n)';
        }

        // ソートアルゴリズム選択
        function selectSortAlgorithm(algorithm) {
            document.querySelectorAll('#sorting .algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.algorithm-card').classList.add('selected');
            
            currentSortAlgorithm = algorithm;
            updateSortExplanation(algorithm);
            logMessage(`ソートアルゴリズム: ${algorithm}を選択`);
        }

        // ソートアルゴリズムの説明更新
        function updateSortExplanation(algorithm) {
            const explanations = {
                bubble: {
                    title: 'バブルソート',
                    text: '隣接する要素を比較し、順序が間違っていれば交換を繰り返すソートアルゴリズムです。',
                    code: `function bubbleSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
}`
                },
                selection: {
                    title: '選択ソート',
                    text: '未ソート部分から最小値を選択し、先頭に配置することを繰り返すソートアルゴリズムです。',
                    code: `function selectionSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        let minIdx = i;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
    }
}`
                },
                insertion: {
                    title: '挿入ソート',
                    text: '要素を一つずつ取り出し、既にソートされた部分の適切な位置に挿入するソートアルゴリズムです。',
                    code: `function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}`
                },
                merge: {
                    title: 'マージソート',
                    text: '分割統治法を使用し、配列を分割してから統合しながらソートするアルゴリズムです。',
                    code: `function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

function merge(left, right) {
    let result = [];
    let i = 0, j = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
        } else {
            result.push(right[j]);
            j++;
        }
    }
    
    return result.concat(left.slice(i)).concat(right.slice(j));
}`
                },
                quick: {
                    title: 'クイックソート',
                    text: 'ピボット要素を選択し、それより小さい要素と大きい要素に分割してソートする分割統治法のアルゴリズムです。',
                    code: `function quickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        let pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

function partition(arr, low, high) {
    let pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}`
                },
                heap: {
                    title: 'ヒープソート',
                    text: 'ヒープデータ構造を使用してソートするアルゴリズムです。最大ヒープを構築してから要素を取り出します。',
                    code: `function heapSort(arr) {
    buildMaxHeap(arr);
    
    for (let i = arr.length - 1; i > 0; i--) {
        [arr[0], arr[i]] = [arr[i], arr[0]];
        heapify(arr, 0, i);
    }
}

function buildMaxHeap(arr) {
    let n = arr.length;
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
        heapify(arr, i, n);
    }
}`
                }
            };

            const explanation = explanations[algorithm];
            document.getElementById('sortExplanationTitle').textContent = explanation.title;
            document.getElementById('sortExplanationText').textContent = explanation.text;
            document.getElementById('sortCodeBlock').innerHTML = `<pre>${explanation.code}</pre>`;
        }

        // ランダム配列生成
        function generateRandomArray() {
            const size = parseInt(document.getElementById('arraySizeSlider').value);
            document.getElementById('arraySizeValue').textContent = size;
            
            sortingArray = Array.from({length: size}, () => Math.floor(Math.random() * 100) + 1);
            displaySortArray();
            resetSortStats();
            logMessage(`サイズ${size}のランダム配列を生成`);
        }

        // ソート配列の表示
        function displaySortArray() {
            const visualization = document.getElementById('sortVisualization');
            visualization.innerHTML = '';
            
            sortingArray.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = value;
                element.id = `sort-element-${index}`;
                
                const indexLabel = document.createElement('div');
                indexLabel.className = 'array-index';
                indexLabel.textContent = index;
                element.appendChild(indexLabel);
                
                visualization.appendChild(element);
            });
        }

        // ソート統計リセット
        function resetSortStats() {
            stats.comparisons = 0;
            stats.swaps = 0;
            stats.arrayAccesses = 0;
            updateSortStats();
            document.getElementById('sortProgress').style.width = '0%';
        }

        // ソート統計更新
        function updateSortStats() {
            document.getElementById('comparisons').textContent = stats.comparisons;
            document.getElementById('swaps').textContent = stats.swaps;
            document.getElementById('arrayAccesses').textContent = stats.arrayAccesses;
        }

        // ソート開始
        async function startSorting() {
            if (isAnimating) return;
            
            isAnimating = true;
            const startTime = Date.now();
            resetSortStats();
            
            animationSpeed = 1100 - parseInt(document.getElementById('speedSlider').value) * 100;
            
            logMessage(`${currentSortAlgorithm}ソート開始`);
            
            switch(currentSortAlgorithm) {
                case 'bubble':
                    await bubbleSortAnimation();
                    break;
                case 'selection':
                    await selectionSortAnimation();
                    break;
                case 'insertion':
                    await insertionSortAnimation();
                    break;
                case 'merge':
                    await mergeSortAnimation();
                    break;
                case 'quick':
                    await quickSortAnimation();
                    break;
                case 'heap':
                    await heapSortAnimation();
                    break;
            }
            
            const endTime = Date.now();
            document.getElementById('timeElapsed').textContent = `${endTime - startTime}ms`;
            
            // 全ての要素をソート済みに
            sortingArray.forEach((_, index) => {
                const element = document.getElementById(`sort-element-${index}`);
                element.classList.add('sorted');
            });
            
            isAnimating = false;
            logMessage(`${currentSortAlgorithm}ソート完了`);
        }

        // バブルソートアニメーション
        async function bubbleSortAnimation() {
            const arr = [...sortingArray];
            const n = arr.length;
            
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    // 比較中の要素をハイライト
                    highlightElements([j, j + 1], 'comparing');
                    stats.comparisons++;
                    stats.arrayAccesses += 2;
                    updateSortStats();
                    
                    await sleep(animationSpeed);
                    
                    if (arr[j] > arr[j + 1]) {
                        // 交換
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        await swapElements(j, j + 1);
                        stats.swaps++;
                        updateSortStats();
                    }
                    
                    // ハイライト解除
                    clearHighlights();
                }
                
                // ソート完了した要素をマーク
                const element = document.getElementById(`sort-element-${n - i - 1}`);
                element.classList.add('sorted');
                
                // プログレス更新
                const progress = ((i + 1) / (n - 1)) * 100;
                document.getElementById('sortProgress').style.width = `${progress}%`;
            }
            
            sortingArray = arr;
        }

        // 選択ソートアニメーション
        async function selectionSortAnimation() {
            const arr = [...sortingArray];
            const n = arr.length;
            
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                highlightElements([i], 'active');
                
                for (let j = i + 1; j < n; j++) {
                    highlightElements([j], 'comparing');
                    stats.comparisons++;
                    stats.arrayAccesses += 2;
                    updateSortStats();
                    
                    await sleep(animationSpeed / 2);
                    
                    if (arr[j] < arr[minIdx]) {
                        clearHighlights();
                        minIdx = j;
                        highlightElements([minIdx], 'active');
                    } else {
                        clearHighlights();
                        highlightElements([i, minIdx], 'active');
                    }
                }
                
                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    await swapElements(i, minIdx);
                    stats.swaps++;
                    updateSortStats();
                }
                
                const element = document.getElementById(`sort-element-${i}`);
                element.classList.add('sorted');
                clearHighlights();
                
                const progress = ((i + 1) / (n - 1)) * 100;
                document.getElementById('sortProgress').style.width = `${progress}%`;
            }
            
            sortingArray = arr;
        }

        // 挿入ソートアニメーション
        async function insertionSortAnimation() {
            const arr = [...sortingArray];
            const n = arr.length;
            
            for (let i = 1; i < n; i++) {
                let key = arr[i];
                let j = i - 1;
                
                highlightElements([i], 'active');
                await sleep(animationSpeed);
                
                while (j >= 0 && arr[j] > key) {
                    highlightElements([j, j + 1], 'comparing');
                    stats.comparisons++;
                    stats.arrayAccesses += 2;
                    updateSortStats();
                    
                    arr[j + 1] = arr[j];
                    await updateElementValue(j + 1, arr[j + 1]);
                    j--;
                    
                    await sleep(animationSpeed);
                }
                
                arr[j + 1] = key;
                await updateElementValue(j + 1, key);
                stats.arrayAccesses++;
                updateSortStats();
                
                clearHighlights();
                
                const progress = (i / (n - 1)) * 100;
                document.getElementById('sortProgress').style.width = `${progress}%`;
            }
            
            sortingArray = arr;
        }

        // マージソートアニメーション（簡略版）
        async function mergeSortAnimation() {
            logMessage('マージソートアニメーション（簡略版）を実行中...');
            await bubbleSortAnimation(); // 簡略版として他のソートを使用
        }

        // クイックソートアニメーション（簡略版）
        async function quickSortAnimation() {
            logMessage('クイックソートアニメーション（簡略版）を実行中...');
            await bubbleSortAnimation(); // 簡略版として他のソートを使用
        }

        // ヒープソートアニメーション（簡略版）
        async function heapSortAnimation() {
            logMessage('ヒープソートアニメーション（簡略版）を実行中...');
            await bubbleSortAnimation(); // 簡略版として他のソートを使用
        }

        // 要素のハイライト
        function highlightElements(indices, className) {
            clearHighlights();
            indices.forEach(index => {
                const element = document.getElementById(`sort-element-${index}`);
                if (element) {
                    element.classList.add(className);
                }
            });
        }

        // ハイライトクリア
        function clearHighlights() {
            document.querySelectorAll('.array-element').forEach(element => {
                element.classList.remove('active', 'comparing');
            });
        }

        // 要素の交換アニメーション
        async function swapElements(i, j) {
            const element1 = document.getElementById(`sort-element-${i}`);
            const element2 = document.getElementById(`sort-element-${j}`);
            
            // 値を交換
            const temp = element1.textContent;
            element1.textContent = element2.textContent;
            element2.textContent = temp;
            
            // アニメーション効果
            element1.style.transform = 'scale(1.1)';
            element2.style.transform = 'scale(1.1)';
            
            await sleep(animationSpeed / 2);
            
            element1.style.transform = 'scale(1)';
            element2.style.transform = 'scale(1)';
        }

        // 要素の値更新
        async function updateElementValue(index, value) {
            const element = document.getElementById(`sort-element-${index}`);
            if (element) {
                element.textContent = value;
                element.style.transform = 'scale(1.1)';
                await sleep(animationSpeed / 4);
                element.style.transform = 'scale(1)';
            }
        }

        // ソート一時停止
        function pauseSorting() {
            isAnimating = false;
            logMessage('ソートを一時停止');
        }

        // ソートステップ実行
        function stepSort() {
            // 実装が複雑なため、通常のソートを低速で実行
            document.getElementById('speedSlider').value = 1;
            startSorting();
        }

        // 探索アルゴリズム選択
        function selectSearchAlgorithm(algorithm) {
            document.querySelectorAll('#searching .algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.algorithm-card').classList.add('selected');
            
            currentSearchAlgorithm = algorithm;
            updateSearchExplanation(algorithm);
            logMessage(`探索アルゴリズム: ${algorithm}を選択`);
        }

        // 探索アルゴリズムの説明更新
        function updateSearchExplanation(algorithm) {
            const explanations = {
                linear: {
                    title: '線形探索',
                    text: '配列の最初から順番に要素を確認していく最も基本的な探索アルゴリズムです。',
                    code: `function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;
        }
    }
    return -1;
}`
                },
                binary: {
                    title: '二分探索',
                    text: 'ソート済み配列に対して、中央の要素と比較しながら探索範囲を半分ずつ狭めていく効率的なアルゴリズムです。',
                    code: `function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}`
                },
                jump: {
                    title: 'ジャンプ探索',
                    text: 'ブロック単位で要素をスキップしながら探索し、見つけたブロック内で線形探索を行うアルゴリズムです。',
                    code: `function jumpSearch(arr, target) {
    let n = arr.length;
    let step = Math.floor(Math.sqrt(n));
    let prev = 0;
    
    while (arr[Math.min(step, n) - 1] < target) {
        prev = step;
        step += Math.floor(Math.sqrt(n));
        if (prev >= n) return -1;
    }
    
    while (arr[prev] < target) {
        prev++;
        if (prev === Math.min(step, n)) return -1;
    }
    
    if (arr[prev] === target) return prev;
    return -1;
}`
                },
                interpolation: {
                    title: '補間探索',
                    text: '一様分布したソート済み配列で、値の大小関係から探索位置を推定する高速なアルゴリズムです。',
                    code: `function interpolationSearch(arr, target) {
    let low = 0;
    let high = arr.length - 1;
    
    while (low <= high && target >= arr[low] && target <= arr[high]) {
        if (low === high) {
            if (arr[low] === target) return low;
            return -1;
        }
        
        let pos = low + Math.floor(((target - arr[low]) / (arr[high] - arr[low])) * (high - low));
        
        if (arr[pos] === target) return pos;
        if (arr[pos] < target) low = pos + 1;
        else high = pos - 1;
    }
    return -1;
}`
                }
            };

            const explanation = explanations[algorithm];
            document.getElementById('searchExplanationTitle').textContent = explanation.title;
            document.getElementById('searchExplanationText').textContent = explanation.text;
            document.getElementById('searchCodeBlock').innerHTML = `<pre>${explanation.code}</pre>`;
        }

        // ソート済み配列生成
        function generateSortedArray() {
            const size = 15;
            searchArray = Array.from({length: size}, (_, i) => (i + 1) * 2 - 1);
            document.getElementById('searchArrayInput').value = searchArray.join(',');
            displaySearchArray();
            logMessage('ソート済み配列を生成');
        }

        // 探索配列の表示
        function displaySearchArray() {
            const input = document.getElementById('searchArrayInput').value;
            searchArray = input.split(',').map(x => parseInt(x.trim())).filter(x => !isNaN(x));
            
            const visualization = document.getElementById('searchVisualization');
            visualization.innerHTML = '';
            
            searchArray.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.textContent = value;
                element.id = `search-element-${index}`;
                
                const indexLabel = document.createElement('div');
                indexLabel.className = 'array-index';
                indexLabel.textContent = index;
                element.appendChild(indexLabel);
                
                visualization.appendChild(element);
            });
        }

        // 探索開始
        async function startSearch() {
            if (isAnimating) return;
            
            displaySearchArray();
            const target = parseInt(document.getElementById('searchValue').value);
            
            if (isNaN(target)) {
                logMessage('有効な検索値を入力してください');
                return;
            }
            
            isAnimating = true;
            const startTime = Date.now();
            
            // 統計リセット
            stats.comparisons = 0;
            let steps = 0;
            document.getElementById('searchComparisons').textContent = '0';
            document.getElementById('searchSteps').textContent = '0';
            document.getElementById('searchResult').textContent = '検索中...';
            
            logMessage(`${currentSearchAlgorithm}探索開始: 値 ${target} を検索`);
            
            let result = -1;
            
            switch(currentSearchAlgorithm) {
                case 'linear':
                    result = await linearSearchAnimation(target);
                    break;
                case 'binary':
                    result = await binarySearchAnimation(target);
                    break;
                case 'jump':
                    result = await jumpSearchAnimation(target);
                    break;
                case 'interpolation':
                    result = await interpolationSearchAnimation(target);
                    break;
            }
            
            const endTime = Date.now();
            document.getElementById('searchTime').textContent = `${endTime - startTime}ms`;
            
            if (result !== -1) {
                document.getElementById('searchResult').textContent = `インデックス ${result}`;
                const element = document.getElementById(`search-element-${result}`);
                element.classList.add('sorted');
                logMessage(`値 ${target} がインデックス ${result} で見つかりました`);
            } else {
                document.getElementById('searchResult').textContent = '見つかりません';
                logMessage(`値 ${target} は見つかりませんでした`);
            }
            
            isAnimating = false;
        }

        // 線形探索アニメーション
        async function linearSearchAnimation(target) {
            for (let i = 0; i < searchArray.length; i++) {
                const element = document.getElementById(`search-element-${i}`);
                element.classList.add('comparing');
                
                stats.comparisons++;
                document.getElementById('searchComparisons').textContent = stats.comparisons;
                document.getElementById('searchSteps').textContent = i + 1;
                
                await sleep(500);
                
                if (searchArray[i] === target) {
                    element.classList.remove('comparing');
                    return i;
                }
                
                element.classList.remove('comparing');
                element.classList.add('visited');
            }
            
            return -1;
        }

        // 二分探索アニメーション
        async function binarySearchAnimation(target) {
            let left = 0;
            let right = searchArray.length - 1;
            let steps = 0;
            
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                steps++;
                
                // 現在の探索範囲をハイライト
                for (let i = left; i <= right; i++) {
                    const element = document.getElementById(`search-element-${i}`);
                    element.classList.add('active');
                }
                
                // 中央要素をハイライト
                const midElement = document.getElementById(`search-element-${mid}`);
                midElement.classList.add('comparing');
                
                stats.comparisons++;
                document.getElementById('searchComparisons').textContent = stats.comparisons;
                document.getElementById('searchSteps').textContent = steps;
                
                await sleep(800);
                
                if (searchArray[mid] === target) {
                    // 見つかった
                    clearSearchHighlights();
                    return mid;
                } else if (searchArray[mid] < target) {
                    // 右半分を探索
                    for (let i = left; i <= mid; i++) {
                        const element = document.getElementById(`search-element-${i}`);
                        element.classList.add('visited');
                    }
                    left = mid + 1;
                } else {
                    // 左半分を探索
                    for (let i = mid; i <= right; i++) {
                        const element = document.getElementById(`search-element-${i}`);
                        element.classList.add('visited');
                    }
                    right = mid - 1;
                }
                
                clearSearchHighlights();
            }
            
            return -1;
        }

        // ジャンプ探索アニメーション（簡略版）
        async function jumpSearchAnimation(target) {
            logMessage('ジャンプ探索（線形探索で代用）');
            return await linearSearchAnimation(target);
        }

        // 補間探索アニメーション（簡略版）
        async function interpolationSearchAnimation(target) {
            logMessage('補間探索（二分探索で代用）');
            return await binarySearchAnimation(target);
        }

        // 探索ハイライトクリア
        function clearSearchHighlights() {
            document.querySelectorAll('#searchVisualization .array-element').forEach(element => {
                element.classList.remove('active', 'comparing');
            });
        }

        // 探索リセット
        function resetSearch() {
            clearSearchHighlights();
            document.querySelectorAll('#searchVisualization .array-element').forEach(element => {
                element.classList.remove('visited', 'sorted');
            });
            
            document.getElementById('searchComparisons').textContent = '0';
            document.getElementById('searchSteps').textContent = '0';
            document.getElementById('searchResult').textContent = '未実行';
            document.getElementById('searchTime').textContent = '0ms';
            
            logMessage('探索をリセット');
        }

        // グラフアルゴリズム選択
        function selectGraphAlgorithm(algorithm) {
            document.querySelectorAll('#graphs .algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.target.closest('.algorithm-card').classList.add('selected');
            
            currentGraphAlgorithm = algorithm;
            updateGraphExplanation(algorithm);
            logMessage(`グラフアルゴリズム: ${algorithm}を選択`);
        }

        // グラフアルゴリズムの説明更新
        function updateGraphExplanation(algorithm) {
            const explanations = {
                dfs: {
                    title: '深さ優先探索 (DFS)',
                    text: '可能な限り深く探索してから、次の分岐を探索するアルゴリズムです。スタックまたは再帰を使用します。',
                    code: `function dfs(graph, start, visited = new Set()) {
    visited.add(start);
    console.log(start);
    
    for (let neighbor of graph[start]) {
        if (!visited.has(neighbor)) {
            dfs(graph, neighbor, visited);
        }
    }
}`
                },
                bfs: {
                    title: '幅優先探索 (BFS)',
                    text: '現在の深度の全てのノードを探索してから、次の深度に進むアルゴリズムです。キューを使用します。',
                    code: `function bfs(graph, start) {
    let visited = new Set();
    let queue = [start];
    
    while (queue.length > 0) {
        let node = queue.shift();
        if (!visited.has(node)) {
            visited.add(node);
            console.log(node);
            
            for (let neighbor of graph[node]) {
                if (!visited.has(neighbor)) {
                    queue.push(neighbor);
                }
            }
        }
    }
}`
                },
                dijkstra: {
                    title: 'ダイクストラ法',
                    text: '重み付きグラフで単一始点から全ての頂点への最短距離を求めるアルゴリズムです。',
                    code: `function dijkstra(graph, start) {
    let distances = {};
    let visited = new Set();
    let pq = new PriorityQueue();
    
    distances[start] = 0;
    pq.enqueue(start, 0);
    
    while (!pq.isEmpty()) {
        let current = pq.dequeue();
        
        if (visited.has(current)) continue;
        visited.add(current);
        
        for (let neighbor of graph[current]) {
            let distance = distances[current] + neighbor.weight;
            if (distance < (distances[neighbor.node] || Infinity)) {
                distances[neighbor.node] = distance;
                pq.enqueue(neighbor.node, distance);
            }
        }
    }
    
    return distances;
}`
                },
                astar: {
                    title: 'A*アルゴリズム',
                    text: 'ヒューリスティック関数を使用して効率的に最短経路を見つける探索アルゴリズムです。',
                    code: `function aStar(graph, start, goal, heuristic) {
    let openSet = new PriorityQueue();
    let gScore = new Map();
    let fScore = new Map();
    
    gScore.set(start, 0);
    fScore.set(start, heuristic(start, goal));
    openSet.enqueue(start, fScore.get(start));
    
    while (!openSet.isEmpty()) {
        let current = openSet.dequeue();
        
        if (current === goal) {
            return reconstructPath(cameFrom, current);
        }
        
        for (let neighbor of graph[current]) {
            let tentativeGScore = gScore.get(current) + distance(current, neighbor);
            
            if (tentativeGScore < (gScore.get(neighbor) || Infinity)) {
                gScore.set(neighbor, tentativeGScore);
                fScore.set(neighbor, gScore.get(neighbor) + heuristic(neighbor, goal));
                openSet.enqueue(neighbor, fScore.get(neighbor));
            }
        }
    }
    
    return null;
}`
                }
            };

            const explanation = explanations[algorithm];
            document.getElementById('graphExplanationTitle').textContent = explanation.title;
            document.getElementById('graphExplanationText').textContent = explanation.text;
            document.getElementById('graphCodeBlock').innerHTML = `<pre>${explanation.code}</pre>`;
        }

        // グラフ生成
        function generateGraph() {
            const graphType = document.getElementById('graphType').value;
            
            // 5x5グリッドグラフを生成
            graphNodes = [];
            graph = [];
            
            for (let i = 0; i < 25; i++) {
                graph[i] = [];
                graphNodes[i] = {
                    id: i,
                    x: 100 + (i % 5) * 80,
                    y: 80 + Math.floor(i / 5) * 80,
                    visited: false,
                    current: false
                };
            }
            
            // グリッド接続を作成
            for (let i = 0; i < 25; i++) {
                const row = Math.floor(i / 5);
                const col = i % 5;
                
                // 右の隣接ノード
                if (col < 4) {
                    graph[i].push(i + 1);
                }
                // 左の隣接ノード
                if (col > 0) {
                    graph[i].push(i - 1);
                }
                // 下の隣接ノード
                if (row < 4) {
                    graph[i].push(i + 5);
                }
                // 上の隣接ノード
                if (row > 0) {
                    graph[i].push(i - 5);
                }
            }
            
            drawGraph();
            logMessage(`${graphType}グラフを生成`);
        }

        // グラフ描画
        function drawGraph() {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // エッジを描画
            for (let i = 0; i < graph.length; i++) {
                const node = graphNodes[i];
                for (let neighbor of graph[i]) {
                    if (neighbor > i) { // 重複描画を避ける
                        const neighborNode = graphNodes[neighbor];
                        
                        ctx.strokeStyle = '#cbd5e1';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(node.x, node.y);
                        ctx.lineTo(neighborNode.x, neighborNode.y);
                        ctx.stroke();
                    }
                }
            }
            
            // ノードを描画
            graphNodes.forEach(node => {
                ctx.fillStyle = node.visited ? '#10b981' : (node.current ? '#f59e0b' : '#3b82f6');
                ctx.beginPath();
                ctx.arc(node.x, node.y, 15, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#1e293b';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ノード番号
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(node.id, node.x, node.y + 4);
            });
        }

        // グラフ探索開始
        async function startGraphTraversal() {
            if (isAnimating) return;
            
            const startNode = parseInt(document.getElementById('startNode').value);
            const endNode = parseInt(document.getElementById('endNode').value);
            
            if (startNode < 0 || startNode >= 25 || endNode < 0 || endNode >= 25) {
                logMessage('有効なノード番号を入力してください (0-24)');
                return;
            }
            
            isAnimating = true;
            resetGraphStats();
            
            // 全ノードリセット
            graphNodes.forEach(node => {
                node.visited = false;
                node.current = false;
            });
            
            const startTime = Date.now();
            logMessage(`${currentGraphAlgorithm}探索開始: ${startNode} → ${endNode}`);
            
            let result = [];
            
            switch(currentGraphAlgorithm) {
                case 'dfs':
                    result = await dfsAnimation(startNode, endNode);
                    break;
                case 'bfs':
                    result = await bfsAnimation(startNode, endNode);
                    break;
                case 'dijkstra':
                    result = await dijkstraAnimation(startNode, endNode);
                    break;
                case 'astar':
                    result = await astarAnimation(startNode, endNode);
                    break;
            }
            
            const endTime = Date.now();
            document.getElementById('graphTime').textContent = `${endTime - startTime}ms`;
            document.getElementById('pathLength').textContent = result.length;
            
            const efficiency = result.length > 0 ? Math.round((result.length / stats.visitedNodes) * 100) : 0;
            document.getElementById('efficiency').textContent = `${efficiency}%`;
            
            isAnimating = false;
            logMessage(`グラフ探索完了: パス長 ${result.length}`);
        }

        // DFSアニメーション
        async function dfsAnimation(start, target) {
            const visited = new Set();
            const path = [];
            
            async function dfsRecursive(node) {
                if (visited.has(node)) return false;
                
                visited.add(node);
                path.push(node);
                stats.visitedNodes++;
                document.getElementById('visitedNodes').textContent = stats.visitedNodes;
                
                graphNodes[node].current = true;
                drawGraph();
                await sleep(600);
                
                if (node === target) {
                    return true;
                }
                
                graphNodes[node].visited = true;
                graphNodes[node].current = false;
                
                for (let neighbor of graph[node]) {
                    if (await dfsRecursive(neighbor)) {
                        return true;
                    }
                }
                
                path.pop();
                return false;
            }
            
            await dfsRecursive(start);
            return path;
        }

        // BFSアニメーション
        async function bfsAnimation(start, target) {
            const visited = new Set();
            const queue = [start];
            const parent = new Map();
            
            visited.add(start);
            
            while (queue.length > 0) {
                const node = queue.shift();
                stats.visitedNodes++;
                document.getElementById('visitedNodes').textContent = stats.visitedNodes;
                
                graphNodes[node].current = true;
                drawGraph();
                await sleep(600);
                
                if (node === target) {
                    // パスを再構築
                    const path = [];
                    let current = target;
                    while (current !== undefined) {
                        path.unshift(current);
                        current = parent.get(current);
                    }
                    return path;
                }
                
                graphNodes[node].visited = true;
                graphNodes[node].current = false;
                
                for (let neighbor of graph[node]) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        parent.set(neighbor, node);
                        queue.push(neighbor);
                    }
                }
                
                drawGraph();
            }
            
            return [];
        }

        // ダイクストラアニメーション（簡略版）
        async function dijkstraAnimation(start, target) {
            logMessage('ダイクストラ法（BFSで代用）');
            return await bfsAnimation(start, target);
        }

        // A*アニメーション（簡略版）
        async function astarAnimation(start, target) {
            logMessage('A*アルゴリズム（BFSで代用）');
            return await bfsAnimation(start, target);
        }

        // グラフ統計リセット
        function resetGraphStats() {
            stats.visitedNodes = 0;
            document.getElementById('visitedNodes').textContent = '0';
            document.getElementById('pathLength').textContent = '0';
            document.getElementById('graphTime').textContent = '0ms';
            document.getElementById('efficiency').textContent = '0%';
        }

        // グラフリセット
        function resetGraph() {
            graphNodes.forEach(node => {
                node.visited = false;
                node.current = false;
            });
            drawGraph();
            resetGraphStats();
            logMessage('グラフをリセット');
        }

        // ユーティリティ関数
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // 初期化時の設定
        window.addEventListener('resize', () => {
            drawDataStructure();
            drawGraph();
        });

        // ページ読み込み完了時の処理
        window.addEventListener('load', () => {
            logMessage('データ構造・アルゴリズム可視化ツール準備完了');
            updateDataStructureExplanation('array');
            updateSortExplanation('bubble');
            updateSearchExplanation('linear');
            updateGraphExplanation('dfs');
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ê©üÊ¢∞Â≠¶Áøí„Ç¢„É´„Ç¥„É™„Ç∫„É†ÂèØË¶ñÂåñ„ÉÑ„Éº„É´</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: radial-gradient(circle at center, #0a0a0a, #1a1a2e, #16213e, #8b008b);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 420px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            padding: 25px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
        }
        
        .main-canvas {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #0f0f23, #1a1a2e);
        }
        
        h1 {
            font-size: 1.3em;
            margin-bottom: 25px;
            background: linear-gradient(45deg, #ff1493, #00bfff, #32cd32, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }
        
        .control-section {
            margin-bottom: 20px;
            padding: 18px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 20, 147, 0.2);
        }
        
        .control-section h3 {
            color: #ff1493;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        label {
            display: block;
            margin: 8px 0 4px;
            color: #ccc;
            font-size: 0.9em;
        }
        
        select, input, button, textarea {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9em;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        button {
            background: linear-gradient(45deg, #ff1493, #00bfff);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 12px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 20, 147, 0.4);
        }
        
        .algorithm-types {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .algo-btn {
            padding: 8px;
            font-size: 0.8em;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 20, 147, 0.3);
            color: #fff;
            text-align: center;
        }
        
        .algo-btn:hover {
            background: rgba(255, 20, 147, 0.2);
        }
        
        .algo-btn.active {
            background: rgba(255, 20, 147, 0.4);
            border-color: #ff1493;
        }
        
        .parameter-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .value-display {
            color: #ff1493;
            font-weight: bold;
            display: inline-block;
            margin-left: 10px;
        }
        
        #canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 0.9em;
            border: 1px solid rgba(255, 20, 147, 0.3);
        }
        
        .stats div {
            margin: 3px 0;
        }
        
        .training-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: rgba(255, 20, 147, 0.2);
            border: 1px solid rgba(255, 20, 147, 0.5);
            color: #fff;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-btn:hover {
            background: rgba(255, 20, 147, 0.4);
        }
        
        .dataset-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        
        .dataset-btn {
            padding: 5px;
            font-size: 0.7em;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 20, 147, 0.2);
        }
        
        .dataset-btn.active {
            background: rgba(255, 20, 147, 0.3);
        }
        
        .hyperparameters {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        textarea {
            height: 60px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }
        
        @keyframes training {
            0% { opacity: 0.6; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.6; transform: scale(0.98); }
        }
        
        .training {
            animation: training 1.5s ease-in-out infinite;
        }
        
        .preset-datasets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .preset-btn {
            padding: 6px;
            font-size: 0.7em;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 20, 147, 0.2);
            color: #ccc;
        }
        
        .preset-btn:hover {
            background: rgba(255, 20, 147, 0.2);
        }
        
        .metrics-panel {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .confusion-matrix {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            margin: 10px 0;
        }
        
        .matrix-cell {
            background: rgba(255, 20, 147, 0.2);
            padding: 5px;
            text-align: center;
            font-size: 0.8em;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>ü§ñ Ê©üÊ¢∞Â≠¶Áøí„Ç¢„É´„Ç¥„É™„Ç∫„É†ÂèØË¶ñÂåñ„ÉÑ„Éº„É´</h1>
            
            <div class="control-section">
                <h3>üéØ „Ç¢„É´„Ç¥„É™„Ç∫„É†ÈÅ∏Êäû</h3>
                <div class="algorithm-types">
                    <button class="algo-btn active" onclick="selectAlgorithm('linear')">Á∑öÂΩ¢ÂõûÂ∏∞</button>
                    <button class="algo-btn" onclick="selectAlgorithm('logistic')">„É≠„Ç∏„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÂõûÂ∏∞</button>
                    <button class="algo-btn" onclick="selectAlgorithm('knn')">k-NN</button>
                    <button class="algo-btn" onclick="selectAlgorithm('svm')">SVM</button>
                    <button class="algo-btn" onclick="selectAlgorithm('tree')">Ê±∫ÂÆöÊú®</button>
                    <button class="algo-btn" onclick="selectAlgorithm('kmeans')">k-means</button>
                    <button class="algo-btn" onclick="selectAlgorithm('neural')">„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà</button>
                    <button class="algo-btn" onclick="selectAlgorithm('perceptron')">„Éë„Éº„Çª„Éó„Éà„É≠„É≥</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>üìä „Éá„Éº„Çø„Çª„ÉÉ„Éà</h3>
                <div class="dataset-options">
                    <button class="dataset-btn active" onclick="selectDataset('linear')">Á∑öÂΩ¢</button>
                    <button class="dataset-btn" onclick="selectDataset('quadratic')">‰∫åÊ¨°</button>
                    <button class="dataset-btn" onclick="selectDataset('circular')">ÂÜÜÂΩ¢</button>
                    <button class="dataset-btn" onclick="selectDataset('spiral')">Ëû∫Êóã</button>
                    <button class="dataset-btn" onclick="selectDataset('clusters')">„ÇØ„É©„Çπ„Çø„Éº</button>
                    <button class="dataset-btn" onclick="selectDataset('random')">„É©„É≥„ÉÄ„É†</button>
                </div>
                
                <div class="parameter-grid">
                    <div>
                        <label>„Çµ„É≥„Éó„É´Êï∞: <span class="value-display" id="sampleCountDisplay">200</span></label>
                        <input type="range" id="sampleCount" min="50" max="1000" value="200">
                    </div>
                    <div>
                        <label>„Éé„Ç§„Ç∫: <span class="value-display" id="noiseDisplay">0.1</span></label>
                        <input type="range" id="noise" min="0" max="1" step="0.05" value="0.1">
                    </div>
                </div>
                
                <button onclick="generateDataset()">üé≤ „Éá„Éº„Çø„Çª„ÉÉ„ÉàÁîüÊàê</button>
                <button onclick="addDataPoint()" style="font-size: 0.8em;">‚ûï ÊâãÂãï„Éá„Éº„ÇøËøΩÂä†</button>
            </div>
            
            <div class="control-section">
                <h3>‚öôÔ∏è „Éè„Ç§„Éë„Éº„Éë„É©„É°„Éº„Çø</h3>
                <div class="hyperparameters">
                    <div>
                        <label>Â≠¶ÁøíÁéá: <span class="value-display" id="learningRateDisplay">0.01</span></label>
                        <input type="range" id="learningRate" min="0.001" max="1" step="0.001" value="0.01">
                    </div>
                    <div>
                        <label>„Ç®„Éù„ÉÉ„ÇØÊï∞: <span class="value-display" id="epochsDisplay">100</span></label>
                        <input type="range" id="epochs" min="10" max="1000" value="100">
                    </div>
                </div>
                
                <div class="hyperparameters">
                    <div>
                        <label>kÂÄ§ (k-NN): <span class="value-display" id="kValueDisplay">5</span></label>
                        <input type="range" id="kValue" min="1" max="20" value="5">
                    </div>
                    <div>
                        <label>CÂÄ§ (SVM): <span class="value-display" id="cValueDisplay">1.0</span></label>
                        <input type="range" id="cValue" min="0.1" max="10" step="0.1" value="1">
                    </div>
                </div>
                
                <div class="hyperparameters">
                    <div>
                        <label>Èö†„ÇåÂ±§: <span class="value-display" id="hiddenLayersDisplay">1</span></label>
                        <input type="range" id="hiddenLayers" min="1" max="5" value="1">
                    </div>
                    <div>
                        <label>„Éã„É•„Éº„É≠„É≥Êï∞: <span class="value-display" id="neuronsDisplay">10</span></label>
                        <input type="range" id="neurons" min="5" max="50" value="10">
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>üöÄ Â≠¶ÁøíÂà∂Âæ°</h3>
                <button onclick="startTraining()" id="trainBtn">‚ñ∂Ô∏è Â≠¶ÁøíÈñãÂßã</button>
                <button onclick="pauseTraining()" id="pauseBtn">‚è∏Ô∏è ‰∏ÄÊôÇÂÅúÊ≠¢</button>
                <button onclick="resetModel()" id="resetBtn">üîÑ „É¢„Éá„É´„É™„Çª„ÉÉ„Éà</button>
                <button onclick="stepTraining()" id="stepBtn">üë£ „Çπ„ÉÜ„ÉÉ„ÉóÂÆüË°å</button>
            </div>
            
            <div class="control-section">
                <h3>üìà ÂèØË¶ñÂåñË®≠ÂÆö</h3>
                <label>
                    <input type="checkbox" id="showDecisionBoundary" checked> Ê±∫ÂÆöÂ¢ÉÁïåË°®Á§∫
                </label>
                <label>
                    <input type="checkbox" id="showGradients"> ÂãæÈÖçË°®Á§∫
                </label>
                <label>
                    <input type="checkbox" id="showConfidence"> ‰ø°È†ºÂ∫¶Ë°®Á§∫
                </label>
                <label>
                    <input type="checkbox" id="animateTraining" checked> Â≠¶Áøí„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                </label>
                
                <label>Ëß£ÂÉèÂ∫¶: <span class="value-display" id="resolutionDisplay">50</span></label>
                <input type="range" id="resolution" min="20" max="100" value="50">
            </div>
            
            <div class="control-section">
                <h3>üìã „Éó„É™„Çª„ÉÉ„Éà</h3>
                <div class="preset-datasets">
                    <button class="preset-btn" onclick="loadPreset('iris')">„Ç¢„Ç§„É™„ÇπÂàÜÈ°û</button>
                    <button class="preset-btn" onclick="loadPreset('housing')">‰ΩèÂÆÖ‰æ°Ê†º‰∫àÊ∏¨</button>
                    <button class="preset-btn" onclick="loadPreset('xor')">XORÂïèÈ°å</button>
                    <button class="preset-btn" onclick="loadPreset('moon')">ÂçäÊúà„Éá„Éº„Çø</button>
                    <button class="preset-btn" onclick="loadPreset('blob')">„Éñ„É≠„ÉñÂàÜÈ°û</button>
                    <button class="preset-btn" onclick="loadPreset('diabetes')">Á≥ñÂ∞øÁóÖ‰∫àÊ∏¨</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>üìä „É¢„Éá„É´Ë©ï‰æ°</h3>
                <div class="metrics-panel">
                    <div>Á≤æÂ∫¶: <span id="accuracy">0.0%</span></div>
                    <div>ÊêçÂ§±: <span id="loss">0.000</span></div>
                    <div>Á≤æÂØÜÂ∫¶: <span id="precision">0.0%</span></div>
                    <div>ÂÜçÁèæÁéá: <span id="recall">0.0%</span></div>
                    <div>F1„Çπ„Ç≥„Ç¢: <span id="f1Score">0.0%</span></div>
                    
                    <div style="margin-top: 10px; font-size: 0.8em;">Ê∑∑ÂêåË°åÂàó:</div>
                    <div class="confusion-matrix" id="confusionMatrix">
                        <div class="matrix-cell">TP: 0</div>
                        <div class="matrix-cell">FP: 0</div>
                        <div class="matrix-cell">FN: 0</div>
                        <div class="matrix-cell">TN: 0</div>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <button onclick="exportModel()">üíæ „É¢„Éá„É´‰øùÂ≠ò</button>
                <button onclick="generateReport()">üìÑ „É¨„Éù„Éº„Éà‰ΩúÊàê</button>
            </div>
        </div>
        
        <div class="main-canvas">
            <canvas id="canvas"></canvas>
            
            <div class="stats">
                <div>„Ç¢„É´„Ç¥„É™„Ç∫„É†: <span id="currentAlgorithm">Á∑öÂΩ¢ÂõûÂ∏∞</span></div>
                <div>„Éá„Éº„ÇøÊï∞: <span id="dataCount">0</span></div>
                <div>ÁâπÂæ¥Èáè: <span id="featureCount">2</span></div>
                <div>„Ç®„Éù„ÉÉ„ÇØ: <span id="currentEpoch">0</span></div>
                <div>Â≠¶ÁøíÁä∂ÊÖã: <span id="trainingStatus">ÂæÖÊ©ü‰∏≠</span></div>
                <div>Ë®àÁÆóÊôÇÈñì: <span id="computeTime">0</span>ms</div>
            </div>
            
            <div class="training-controls">
                <button class="control-btn" onclick="addPositivePoint()" title="Ê≠£‰æãËøΩÂä†">+</button>
                <button class="control-btn" onclick="addNegativePoint()" title="Ë≤†‰æãËøΩÂä†">-</button>
                <button class="control-btn" onclick="clearData()" title="„Éá„Éº„Çø„ÇØ„É™„Ç¢">üóëÔ∏è</button>
                <button class="control-btn" onclick="shuffle()" title="„Éá„Éº„Çø„Ç∑„É£„ÉÉ„Éï„É´">üîÄ</button>
                <button class="control-btn" onclick="splitData()" title="Ë®ìÁ∑¥/„ÉÜ„Çπ„ÉàÂàÜÂâ≤">‚úÇÔ∏è</button>
            </div>
        </div>
    </div>

    <script>
        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let dataPoints = [];
        let testPoints = [];
        let currentAlgorithm = 'linear';
        let currentDataset = 'linear';
        let model = null;
        let isTraining = false;
        let trainingEpoch = 0;
        let animationId = null;
        let decisionBoundary = [];
        
        // Ê©üÊ¢∞Â≠¶Áøí„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÂÆüË£Ö
        class MachineLearningModel {
            constructor(type) {
                this.type = type;
                this.weights = [];
                this.bias = 0;
                this.isClassification = ['logistic', 'svm', 'knn', 'tree', 'perceptron'].includes(type);
                this.history = { loss: [], accuracy: [] };
                this.initialize();
            }
            
            initialize() {
                const featureCount = 2;
                switch (this.type) {
                    case 'linear':
                    case 'logistic':
                    case 'perceptron':
                        this.weights = Array(featureCount).fill(0).map(() => Math.random() * 0.1 - 0.05);
                        this.bias = Math.random() * 0.1 - 0.05;
                        break;
                    case 'neural':
                        this.initializeNeuralNetwork();
                        break;
                    case 'svm':
                        this.weights = Array(featureCount).fill(0).map(() => Math.random() * 0.1 - 0.05);
                        this.bias = 0;
                        break;
                    case 'tree':
                        this.tree = null;
                        break;
                    case 'kmeans':
                        this.centroids = [];
                        this.initializeCentroids();
                        break;
                }
            }
            
            initializeNeuralNetwork() {
                const hiddenLayers = parseInt(document.getElementById('hiddenLayers').value);
                const neurons = parseInt(document.getElementById('neurons').value);
                
                this.layers = [];
                const layerSizes = [2]; // ÂÖ•ÂäõÂ±§
                
                for (let i = 0; i < hiddenLayers; i++) {
                    layerSizes.push(neurons);
                }
                layerSizes.push(this.isClassification ? 2 : 1); // Âá∫ÂäõÂ±§
                
                for (let i = 0; i < layerSizes.length - 1; i++) {
                    const weights = [];
                    for (let j = 0; j < layerSizes[i]; j++) {
                        weights.push(Array(layerSizes[i + 1]).fill(0).map(() => Math.random() * 0.4 - 0.2));
                    }
                    this.layers.push({
                        weights: weights,
                        biases: Array(layerSizes[i + 1]).fill(0).map(() => Math.random() * 0.1 - 0.05)
                    });
                }
            }
            
            initializeCentroids() {
                const k = parseInt(document.getElementById('kValue').value);
                this.centroids = [];
                
                for (let i = 0; i < k; i++) {
                    this.centroids.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    });
                }
            }
            
            predict(x, y) {
                const features = [x / canvas.width, y / canvas.height]; // Ê≠£Ë¶èÂåñ
                
                switch (this.type) {
                    case 'linear':
                        return this.linearPredict(features);
                    case 'logistic':
                        return this.logisticPredict(features);
                    case 'knn':
                        return this.knnPredict(x, y);
                    case 'svm':
                        return this.svmPredict(features);
                    case 'perceptron':
                        return this.perceptronPredict(features);
                    case 'neural':
                        return this.neuralPredict(features);
                    case 'tree':
                        return this.treePredict(features);
                    case 'kmeans':
                        return this.kmeansPredict(x, y);
                    default:
                        return 0;
                }
            }
            
            linearPredict(features) {
                let prediction = this.bias;
                for (let i = 0; i < features.length; i++) {
                    prediction += this.weights[i] * features[i];
                }
                return prediction;
            }
            
            logisticPredict(features) {
                const z = this.linearPredict(features);
                return 1 / (1 + Math.exp(-z));
            }
            
            knnPredict(x, y) {
                const k = parseInt(document.getElementById('kValue').value);
                const distances = dataPoints.map(point => ({
                    distance: Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2),
                    label: point.label
                }));
                
                distances.sort((a, b) => a.distance - b.distance);
                const nearestK = distances.slice(0, k);
                
                if (this.isClassification) {
                    const votes = {};
                    nearestK.forEach(neighbor => {
                        votes[neighbor.label] = (votes[neighbor.label] || 0) + 1;
                    });
                    return Object.keys(votes).reduce((a, b) => votes[a] > votes[b] ? a : b);
                } else {
                    return nearestK.reduce((sum, neighbor) => sum + neighbor.label, 0) / k;
                }
            }
            
            svmPredict(features) {
                let decision = this.bias;
                for (let i = 0; i < features.length; i++) {
                    decision += this.weights[i] * features[i];
                }
                return decision > 0 ? 1 : 0;
            }
            
            perceptronPredict(features) {
                let activation = this.bias;
                for (let i = 0; i < features.length; i++) {
                    activation += this.weights[i] * features[i];
                }
                return activation > 0 ? 1 : 0;
            }
            
            neuralPredict(features) {
                let activations = features;
                
                for (const layer of this.layers) {
                    const newActivations = [];
                    
                    for (let j = 0; j < layer.biases.length; j++) {
                        let sum = layer.biases[j];
                        for (let i = 0; i < activations.length; i++) {
                            sum += activations[i] * layer.weights[i][j];
                        }
                        newActivations.push(this.sigmoid(sum));
                    }
                    
                    activations = newActivations;
                }
                
                return this.isClassification ? (activations[0] > 0.5 ? 1 : 0) : activations[0];
            }
            
            treePredict(features) {
                if (!this.tree) return 0;
                return this.traverseTree(this.tree, features);
            }
            
            kmeansPredict(x, y) {
                let minDistance = Infinity;
                let closestCluster = 0;
                
                for (let i = 0; i < this.centroids.length; i++) {
                    const distance = Math.sqrt((this.centroids[i].x - x) ** 2 + (this.centroids[i].y - y) ** 2);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCluster = i;
                    }
                }
                
                return closestCluster;
            }
            
            train() {
                if (dataPoints.length === 0) return;
                
                const learningRate = parseFloat(document.getElementById('learningRate').value);
                
                switch (this.type) {
                    case 'linear':
                    case 'logistic':
                        this.gradientDescentStep(learningRate);
                        break;
                    case 'perceptron':
                        this.perceptronStep(learningRate);
                        break;
                    case 'neural':
                        this.backpropagationStep(learningRate);
                        break;
                    case 'svm':
                        this.svmStep(learningRate);
                        break;
                    case 'tree':
                        this.buildDecisionTree();
                        break;
                    case 'kmeans':
                        this.kmeansStep();
                        break;
                }
                
                this.updateMetrics();
            }
            
            gradientDescentStep(learningRate) {
                let weightGradients = Array(this.weights.length).fill(0);
                let biasGradient = 0;
                
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    const prediction = this.type === 'linear' ? 
                        this.linearPredict(features) : 
                        this.logisticPredict(features);
                    
                    const error = point.label - prediction;
                    
                    if (this.type === 'logistic') {
                        const derivative = prediction * (1 - prediction);
                        for (let i = 0; i < features.length; i++) {
                            weightGradients[i] += error * derivative * features[i];
                        }
                        biasGradient += error * derivative;
                    } else {
                        for (let i = 0; i < features.length; i++) {
                            weightGradients[i] += error * features[i];
                        }
                        biasGradient += error;
                    }
                }
                
                // Èáç„ÅøÊõ¥Êñ∞
                for (let i = 0; i < this.weights.length; i++) {
                    this.weights[i] += learningRate * weightGradients[i] / dataPoints.length;
                }
                this.bias += learningRate * biasGradient / dataPoints.length;
            }
            
            perceptronStep(learningRate) {
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    const prediction = this.perceptronPredict(features);
                    const error = point.label - prediction;
                    
                    if (error !== 0) {
                        for (let i = 0; i < features.length; i++) {
                            this.weights[i] += learningRate * error * features[i];
                        }
                        this.bias += learningRate * error;
                    }
                }
            }
            
            backpropagationStep(learningRate) {
                // Á∞°Áï•Âåñ„Åï„Çå„Åü„Éê„ÉÉ„ÇØ„Éó„É≠„Éë„Ç≤„Éº„Ç∑„Éß„É≥
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    const prediction = this.neuralPredict(features);
                    const error = point.label - prediction;
                    
                    // Âá∫ÂäõÂ±§„ÅÆÈáç„ÅøÊõ¥Êñ∞ÔºàÁ∞°Áï•ÁâàÔºâ
                    const lastLayer = this.layers[this.layers.length - 1];
                    for (let i = 0; i < lastLayer.weights.length; i++) {
                        for (let j = 0; j < lastLayer.weights[i].length; j++) {
                            lastLayer.weights[i][j] += learningRate * error * 0.1;
                        }
                    }
                }
            }
            
            svmStep(learningRate) {
                const C = parseFloat(document.getElementById('cValue').value);
                
                for (const point of dataPoints) {
                    const features = [point.x / canvas.width, point.y / canvas.height];
                    let decision = this.bias;
                    for (let i = 0; i < features.length; i++) {
                        decision += this.weights[i] * features[i];
                    }
                    
                    const margin = point.label * decision;
                    
                    if (margin < 1) {
                        // „Çµ„Éù„Éº„Éà„Éô„ÇØ„Çø„Éº
                        for (let i = 0; i < features.length; i++) {
                            this.weights[i] += learningRate * (point.label * features[i] - 2 * this.weights[i] / C);
                        }
                        this.bias += learningRate * point.label;
                    } else {
                        // Ê≠£ÂâáÂåñÈ†Ö„ÅÆ„Åø
                        for (let i = 0; i < features.length; i++) {
                            this.weights[i] += learningRate * (-2 * this.weights[i] / C);
                        }
                    }
                }
            }
            
            kmeansStep() {
                // „ÇØ„É©„Çπ„Çø„ÉºÂâ≤„ÇäÂΩì„Å¶
                const clusters = Array(this.centroids.length).fill().map(() => []);
                
                for (const point of dataPoints) {
                    const clusterIndex = this.kmeansPredict(point.x, point.y);
                    clusters[clusterIndex].push(point);
                }
                
                // ÈáçÂøÉÊõ¥Êñ∞
                for (let i = 0; i < this.centroids.length; i++) {
                    if (clusters[i].length > 0) {
                        const sumX = clusters[i].reduce((sum, point) => sum + point.x, 0);
                        const sumY = clusters[i].reduce((sum, point) => sum + point.y, 0);
                        this.centroids[i].x = sumX / clusters[i].length;
                        this.centroids[i].y = sumY / clusters[i].length;
                    }
                }
            }
            
            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }
            
            updateMetrics() {
                if (dataPoints.length === 0) return;
                
                let correct = 0;
                let totalLoss = 0;
                let tp = 0, fp = 0, fn = 0, tn = 0;
                
                for (const point of dataPoints) {
                    const prediction = this.predict(point.x, point.y);
                    
                    if (this.isClassification) {
                        const predicted = prediction > 0.5 ? 1 : 0;
                        const actual = point.label;
                        
                        if (predicted === actual) correct++;
                        
                        if (actual === 1 && predicted === 1) tp++;
                        else if (actual === 0 && predicted === 1) fp++;
                        else if (actual === 1 && predicted === 0) fn++;
                        else if (actual === 0 && predicted === 0) tn++;
                        
                        // „ÇØ„É≠„Çπ„Ç®„É≥„Éà„É≠„Éî„ÉºÊêçÂ§±
                        const p = Math.max(0.0001, Math.min(0.9999, prediction));
                        totalLoss += -(actual * Math.log(p) + (1 - actual) * Math.log(1 - p));
                    } else {
                        // Âπ≥Âùá‰∫å‰πóË™§Â∑Æ
                        const error = prediction - point.label;
                        totalLoss += error * error;
                        
                        // ÂõûÂ∏∞„ÅÆÁ≤æÂ∫¶ÔºàË™§Â∑Æ„ÅåÂ∞è„Åï„Åë„Çå„Å∞Ê≠£Ëß£„Å®„Åø„Å™„ÅôÔºâ
                        if (Math.abs(error) < 0.1) correct++;
                    }
                }
                
                const accuracy = (correct / dataPoints.length) * 100;
                const loss = totalLoss / dataPoints.length;
                
                document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
                document.getElementById('loss').textContent = loss.toFixed(3);
                
                if (this.isClassification) {
                    const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
                    const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
                    const f1 = precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0;
                    
                    document.getElementById('precision').textContent = (precision * 100).toFixed(1) + '%';
                    document.getElementById('recall').textContent = (recall * 100).toFixed(1) + '%';
                    document.getElementById('f1Score').textContent = (f1 * 100).toFixed(1) + '%';
                    
                    // Ê∑∑ÂêåË°åÂàóÊõ¥Êñ∞
                    const matrix = document.getElementById('confusionMatrix');
                    matrix.children[0].textContent = `TP: ${tp}`;
                    matrix.children[1].textContent = `FP: ${fp}`;
                    matrix.children[2].textContent = `FN: ${fn}`;
                    matrix.children[3].textContent = `TN: ${tn}`;
                }
                
                this.history.accuracy.push(accuracy);
                this.history.loss.push(loss);
            }
        }
        
        // „Ç≠„É£„É≥„Éê„ÇπÂàùÊúüÂåñ
        function initCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }
        
        // „Ç¢„É´„Ç¥„É™„Ç∫„É†ÈÅ∏Êäû
        function selectAlgorithm(algorithm) {
            currentAlgorithm = algorithm;
            document.querySelectorAll('.algo-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const names = {
                linear: 'Á∑öÂΩ¢ÂõûÂ∏∞',
                logistic: '„É≠„Ç∏„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÂõûÂ∏∞',
                knn: 'k-NN',
                svm: 'SVM',
                tree: 'Ê±∫ÂÆöÊú®',
                kmeans: 'k-means',
                neural: '„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà',
                perceptron: '„Éë„Éº„Çª„Éó„Éà„É≠„É≥'
            };
            
            document.getElementById('currentAlgorithm').textContent = names[algorithm];
            resetModel();
        }
        
        // „Éá„Éº„Çø„Çª„ÉÉ„ÉàÈÅ∏Êäû„ÉªÁîüÊàê
        function selectDataset(dataset) {
            currentDataset = dataset;
            document.querySelectorAll('.dataset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            generateDataset();
        }
        
        function generateDataset() {
            const sampleCount = parseInt(document.getElementById('sampleCount').value);
            const noise = parseFloat(document.getElementById('noise').value);
            
            dataPoints = [];
            
            switch (currentDataset) {
                case 'linear':
                    generateLinearData(sampleCount, noise);
                    break;
                case 'quadratic':
                    generateQuadraticData(sampleCount, noise);
                    break;
                case 'circular':
                    generateCircularData(sampleCount, noise);
                    break;
                case 'spiral':
                    generateSpiralData(sampleCount, noise);
                    break;
                case 'clusters':
                    generateClusterData(sampleCount, noise);
                    break;
                case 'random':
                    generateRandomData(sampleCount);
                    break;
            }
            
            updateStats();
            draw();
        }
        
        function generateLinearData(count, noise) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * canvas.width;
                const y = x * 0.5 + canvas.height * 0.3 + (Math.random() - 0.5) * noise * canvas.height;
                const label = currentAlgorithm === 'kmeans' ? 0 : (y > canvas.height / 2 ? 1 : 0);
                dataPoints.push({x, y, label});
            }
        }
        
        function generateQuadraticData(count, noise) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * canvas.width;
                const normalizedX = (x / canvas.width - 0.5) * 4;
                const y = canvas.height * (0.5 - normalizedX * normalizedX * 0.1) + (Math.random() - 0.5) * noise * canvas.height;
                const label = y < canvas.height / 2 ? 1 : 0;
                dataPoints.push({x, y: Math.max(0, Math.min(canvas.height, y)), label});
            }
        }
        
        function generateCircularData(count, noise) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 150 + 50 + (Math.random() - 0.5) * noise * 50;
                const x = canvas.width / 2 + radius * Math.cos(angle);
                const y = canvas.height / 2 + radius * Math.sin(angle);
                const centerDistance = Math.sqrt((x - canvas.width/2)**2 + (y - canvas.height/2)**2);
                const label = centerDistance < 100 ? 1 : 0;
                dataPoints.push({x: Math.max(0, Math.min(canvas.width, x)), 
                               y: Math.max(0, Math.min(canvas.height, y)), label});
            }
        }
        
        function generateSpiralData(count, noise) {
            for (let i = 0; i < count; i++) {
                const t = i / count * 4 * Math.PI;
                const radius = t * 10;
                const x = canvas.width / 2 + radius * Math.cos(t) + (Math.random() - 0.5) * noise * 20;
                const y = canvas.height / 2 + radius * Math.sin(t) + (Math.random() - 0.5) * noise * 20;
                const label = Math.floor(t / (2 * Math.PI)) % 2;
                dataPoints.push({x: Math.max(0, Math.min(canvas.width, x)), 
                               y: Math.max(0, Math.min(canvas.height, y)), label});
            }
        }
        
        function generateClusterData(count, noise) {
            const centers = [
                {x: canvas.width * 0.3, y: canvas.height * 0.3},
                {x: canvas.width * 0.7, y: canvas.height * 0.3},
                {x: canvas.width * 0.5, y: canvas.height * 0.7}
            ];
            
            for (let i = 0; i < count; i++) {
                const cluster = Math.floor(Math.random() * centers.length);
                const center = centers[cluster];
                const x = center.x + (Math.random() - 0.5) * 100 + (Math.random() - 0.5) * noise * 50;
                const y = center.y + (Math.random() - 0.5) * 100 + (Math.random() - 0.5) * noise * 50;
                dataPoints.push({x: Math.max(0, Math.min(canvas.width, x)), 
                               y: Math.max(0, Math.min(canvas.height, y)), label: cluster});
            }
        }
        
        function generateRandomData(count) {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const label = Math.random() > 0.5 ? 1 : 0;
                dataPoints.push({x, y, label});
            }
        }
        
        // Â≠¶ÁøíÂà∂Âæ°
        function startTraining() {
            if (!model) {
                model = new MachineLearningModel(currentAlgorithm);
            }
            
            if (!isTraining) {
                isTraining = true;
                document.getElementById('trainingStatus').textContent = 'Â≠¶Áøí‰∏≠';
                trainModel();
            }
        }
        
        function pauseTraining() {
            isTraining = false;
            document.getElementById('trainingStatus').textContent = '‰∏ÄÊôÇÂÅúÊ≠¢';
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function resetModel() {
            pauseTraining();
            model = new MachineLearningModel(currentAlgorithm);
            trainingEpoch = 0;
            document.getElementById('currentEpoch').textContent = '0';
            document.getElementById('trainingStatus').textContent = 'ÂæÖÊ©ü‰∏≠';
            updateDecisionBoundary();
            draw();
        }
        
        function stepTraining() {
            if (!model) {
                model = new MachineLearningModel(currentAlgorithm);
            }
            
            model.train();
            trainingEpoch++;
            document.getElementById('currentEpoch').textContent = trainingEpoch;
            updateDecisionBoundary();
            draw();
        }
        
        async function trainModel() {
            const maxEpochs = parseInt(document.getElementById('epochs').value);
            const animateTraining = document.getElementById('animateTraining').checked;
            
            while (isTraining && trainingEpoch < maxEpochs) {
                const startTime = performance.now();
                
                model.train();
                trainingEpoch++;
                
                document.getElementById('currentEpoch').textContent = trainingEpoch;
                
                if (animateTraining && trainingEpoch % 5 === 0) {
                    updateDecisionBoundary();
                    draw();
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                const endTime = performance.now();
                document.getElementById('computeTime').textContent = Math.round(endTime - startTime);
            }
            
            if (trainingEpoch >= maxEpochs) {
                pauseTraining();
                document.getElementById('trainingStatus').textContent = 'ÂÆå‰∫Ü';
            }
            
            updateDecisionBoundary();
            draw();
        }
        
        // Ê±∫ÂÆöÂ¢ÉÁïåÊõ¥Êñ∞
        function updateDecisionBoundary() {
            if (!model || !document.getElementById('showDecisionBoundary').checked) {
                decisionBoundary = [];
                return;
            }
            
            const resolution = parseInt(document.getElementById('resolution').value);
            const stepX = canvas.width / resolution;
            const stepY = canvas.height / resolution;
            
            decisionBoundary = [];
            
            for (let x = 0; x < canvas.width; x += stepX) {
                for (let y = 0; y < canvas.height; y += stepY) {
                    const prediction = model.predict(x, y);
                    decisionBoundary.push({x, y, prediction});
                }
            }
        }
        
        // ÊèèÁîª
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ËÉåÊôØ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
            const gradient = ctx.createRadialGradient(
                canvas.width/2, canvas.height/2, 0,
                canvas.width/2, canvas.height/2, canvas.width/2
            );
            gradient.addColorStop(0, 'rgba(15, 15, 35, 0.1)');
            gradient.addColorStop(1, 'rgba(139, 0, 139, 0.3)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ê±∫ÂÆöÂ¢ÉÁïåÊèèÁîª
            drawDecisionBoundary();
            
            // „Éá„Éº„Çø„Éù„Ç§„É≥„ÉàÊèèÁîª
            drawDataPoints();
            
            // k-means„ÅÆÈáçÂøÉÊèèÁîª
            if (model && model.type === 'kmeans') {
                drawCentroids();
            }
        }
        
        function drawDecisionBoundary() {
            if (decisionBoundary.length === 0) return;
            
            const resolution = parseInt(document.getElementById('resolution').value);
            const stepX = canvas.width / resolution;
            const stepY = canvas.height / resolution;
            
            for (const point of decisionBoundary) {
                let alpha = 0.3;
                let color;
                
                if (model.isClassification || model.type === 'kmeans') {
                    const hue = point.prediction * 60; // Ëâ≤Áõ∏„ÅßÂàÜÈ°û
                    color = `hsla(${hue}, 70%, 50%, ${alpha})`;
                } else {
                    // ÂõûÂ∏∞„ÅÆÂ†¥Âêà„ÅØÂÄ§„Å´Âøú„Åò„Å¶Ëâ≤„ÇíÂ§â„Åà„Çã
                    const intensity = Math.max(0, Math.min(1, point.prediction));
                    color = `rgba(${intensity * 255}, ${(1-intensity) * 255}, 100, ${alpha})`;
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(point.x, point.y, stepX, stepY);
            }
        }
        
        function drawDataPoints() {
            for (const point of dataPoints) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                
                if (currentAlgorithm === 'kmeans') {
                    const hue = point.label * 60;
                    ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                } else {
                    ctx.fillStyle = point.label > 0.5 ? '#ff6b6b' : '#4ecdc4';
                }
                
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        function drawCentroids() {
            for (let i = 0; i < model.centroids.length; i++) {
                const centroid = model.centroids[i];
                ctx.beginPath();
                ctx.arc(centroid.x, centroid.y, 12, 0, Math.PI * 2);
                
                const hue = i * 60;
                ctx.fillStyle = `hsl(${hue}, 70%, 40%)`;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // XÂç∞
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centroid.x - 6, centroid.y - 6);
                ctx.lineTo(centroid.x + 6, centroid.y + 6);
                ctx.moveTo(centroid.x + 6, centroid.y - 6);
                ctx.lineTo(centroid.x - 6, centroid.y + 6);
                ctx.stroke();
            }
        }
        
        // „Éá„Éº„ÇøÊìç‰Ωú
        function addDataPoint() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const label = Math.random() > 0.5 ? 1 : 0;
            dataPoints.push({x, y, label});
            updateStats();
            draw();
        }
        
        function addPositivePoint() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            dataPoints.push({x, y, label: 1});
            updateStats();
            draw();
        }
        
        function addNegativePoint() {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            dataPoints.push({x, y, label: 0});
            updateStats();
            draw();
        }
        
        function clearData() {
            dataPoints = [];
            testPoints = [];
            updateStats();
            draw();
        }
        
        function shuffle() {
            for (let i = dataPoints.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [dataPoints[i], dataPoints[j]] = [dataPoints[j], dataPoints[i]];
            }
            draw();
        }
        
        function splitData() {
            const splitRatio = 0.8;
            const trainSize = Math.floor(dataPoints.length * splitRatio);
            
            shuffle();
            testPoints = dataPoints.splice(trainSize);
            
            console.log(`Ë®ìÁ∑¥„Éá„Éº„Çø: ${dataPoints.length}, „ÉÜ„Çπ„Éà„Éá„Éº„Çø: ${testPoints.length}`);
            updateStats();
        }
        
        // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø
        function loadPreset(preset) {
            switch (preset) {
                case 'iris':
                    selectAlgorithm('logistic');
                    selectDataset('clusters');
                    break;
                case 'housing':
                    selectAlgorithm('linear');
                    selectDataset('linear');
                    break;
                case 'xor':
                    selectAlgorithm('neural');
                    loadXORData();
                    break;
                case 'moon':
                    selectAlgorithm('svm');
                    selectDataset('circular');
                    break;
                case 'blob':
                    selectAlgorithm('kmeans');
                    selectDataset('clusters');
                    break;
                case 'diabetes':
                    selectAlgorithm('logistic');
                    selectDataset('random');
                    break;
            }
        }
        
        function loadXORData() {
            dataPoints = [
                {x: canvas.width * 0.3, y: canvas.height * 0.3, label: 0},
                {x: canvas.width * 0.7, y: canvas.height * 0.3, label: 1},
                {x: canvas.width * 0.3, y: canvas.height * 0.7, label: 1},
                {x: canvas.width * 0.7, y: canvas.height * 0.7, label: 0}
            ];
            
            // „Éé„Ç§„Ç∫‰ªò„Åç„Çµ„É≥„Éó„É´ËøΩÂä†
            for (let i = 0; i < 100; i++) {
                const basePoint = dataPoints[i % 4];
                const x = basePoint.x + (Math.random() - 0.5) * 60;
                const y = basePoint.y + (Math.random() - 0.5) * 60;
                dataPoints.push({x, y, label: basePoint.label});
            }
            
            updateStats();
            draw();
        }
        
        // Áµ±Ë®àÊõ¥Êñ∞
        function updateStats() {
            document.getElementById('dataCount').textContent = dataPoints.length;
            document.getElementById('sampleCountDisplay').textContent = document.getElementById('sampleCount').value;
            document.getElementById('noiseDisplay').textContent = document.getElementById('noise').value;
        }
        
        // Ë°®Á§∫ÂÄ§Êõ¥Êñ∞
        function updateDisplayValues() {
            document.getElementById('learningRateDisplay').textContent = document.getElementById('learningRate').value;
            document.getElementById('epochsDisplay').textContent = document.getElementById('epochs').value;
            document.getElementById('kValueDisplay').textContent = document.getElementById('kValue').value;
            document.getElementById('cValueDisplay').textContent = document.getElementById('cValue').value;
            document.getElementById('hiddenLayersDisplay').textContent = document.getElementById('hiddenLayers').value;
            document.getElementById('neuronsDisplay').textContent = document.getElementById('neurons').value;
            document.getElementById('resolutionDisplay').textContent = document.getElementById('resolution').value;
        }
        
        // „Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ©üËÉΩ
        function exportModel() {
            if (!model) return;
            
            const data = {
                algorithm: currentAlgorithm,
                weights: model.weights,
                bias: model.bias,
                history: model.history,
                dataPoints: dataPoints,
                parameters: {
                    learningRate: parseFloat(document.getElementById('learningRate').value),
                    epochs: parseInt(document.getElementById('epochs').value)
                }
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ml_model_${currentAlgorithm}_${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        function generateReport() {
            let report = `Ê©üÊ¢∞Â≠¶Áøí„É¨„Éù„Éº„Éà\n`;
            report += `ÁîüÊàêÊó•ÊôÇ: ${new Date().toLocaleString()}\n\n`;
            report += `„Ç¢„É´„Ç¥„É™„Ç∫„É†: ${currentAlgorithm}\n`;
            report += `„Éá„Éº„ÇøÊï∞: ${dataPoints.length}\n`;
            report += `„Ç®„Éù„ÉÉ„ÇØÊï∞: ${trainingEpoch}\n\n`;
            
            if (model) {
                const accuracy = document.getElementById('accuracy').textContent;
                const loss = document.getElementById('loss').textContent;
                report += `Á≤æÂ∫¶: ${accuracy}\n`;
                report += `ÊêçÂ§±: ${loss}\n`;
            }
            
            const reportBlob = new Blob([report], {type: 'text/plain'});
            const url = URL.createObjectURL(reportBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ml_report_${Date.now()}.txt`;
            link.click();
            URL.revokeObjectURL(url);
        }
        
        // „Éû„Ç¶„Çπ„Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const label = e.shiftKey ? 0 : 1; // Shift„Ç≠„Éº„ÅßË≤†‰æã
            dataPoints.push({x, y, label});
            updateStats();
            draw();
        });
        
        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
        ['learningRate', 'epochs', 'kValue', 'cValue', 'hiddenLayers', 'neurons', 'resolution', 'sampleCount', 'noise'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateDisplayValues);
        });
        
        document.getElementById('showDecisionBoundary').addEventListener('change', () => {
            updateDecisionBoundary();
            draw();
        });
        
        // ÂàùÊúüÂåñ
        window.addEventListener('resize', initCanvas);
        initCanvas();
        updateDisplayValues();
        generateDataset();
        resetModel();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Á´πÂàá„Çä„Ç≤„Éº„É† - ÁàΩÂø´Êñ¨ÊíÉ‰ΩìÈ®ì</title>
    <meta name="description" content="„É™„Ç¢„É´„Å™Áâ©ÁêÜÊºîÁÆó„ÅßÁ´π„Çí„Çπ„Éë„ÉÉ„Å®Âàá„ÇãÁàΩÂø´„Ç≤„Éº„É†">
    
    <!-- PWAË®≠ÂÆö -->
    <meta name="theme-color" content="#2E7D32">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Á´πÂàá„Çä„Ç≤„Éº„É†">
    
    <link rel="manifest" id="manifest-placeholder">
    <link rel="icon" type="image/png" sizes="192x192" id="icon-placeholder">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            display: block;
            cursor: none;
            background: linear-gradient(180deg, #87CEEB 0%, #98FB98 50%, #228B22 100%);
            touch-action: none;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .score-display {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .combo-display {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #FFD700;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }

        .start-button {
            padding: 15px 30px;
            font-size: 24px;
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: all;
        }

        .start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .instructions {
            text-align: center;
            margin-bottom: 30px;
            font-size: 18px;
        }

        .slice-effect {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes sliceFlash {
            0% { opacity: 1; width: 2px; }
            100% { opacity: 0; width: 8px; }
        }

        .slice-line {
            background: linear-gradient(90deg, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,1) 50%, 
                rgba(255,255,255,0) 100%);
            animation: sliceFlash 0.3s ease-out;
        }

        @media (max-width: 768px) {
            .score-display, .combo-display {
                font-size: 20px;
            }
            
            .start-button {
                font-size: 20px;
                padding: 12px 24px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="score-display">
            „Çπ„Ç≥„Ç¢: <span id="score">0</span>
        </div>
        <div class="combo-display">
            „Ç≥„É≥„Éú: <span id="combo">0</span>
        </div>
    </div>

    <div class="start-screen" id="startScreen">
        <div class="instructions">
            <h1>üéã Á´πÂàá„Çä„Ç≤„Éº„É† üéã</h1>
            <p>„Çπ„ÉØ„Ç§„Éó„Åó„Å¶Á´π„Çí„Çπ„Éë„ÉÉ„Å®Âàá„Çç„ÅÜÔºÅ</p>
            <p>ÈÄ£Á∂ö„ÅßÂàá„Å£„Å¶„Ç≥„É≥„Éú„ÇíÊ±∫„ÇÅ„Çà„ÅÜÔºÅ</p>
        </div>
        <button class="start-button" onclick="startGame()">„Ç≤„Éº„É†ÈñãÂßã</button>
    </div>

    <script>
        // „Ç≤„Éº„É†Áä∂ÊÖãÁÆ°ÁêÜ
        let gameState = {
            isPlaying: false,
            score: 0,
            combo: 0,
            comboTimer: 0,
            lastCutTime: 0
        };

        // CanvasË®≠ÂÆö
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Áâ©ÁêÜÊºîÁÆóÁî®„ÅÆÂÆöÊï∞
        const GRAVITY = 0.5;
        const FRICTION = 0.98;
        const BOUNCE_DAMPING = 0.7;

        // Á´π„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÈÖçÂàó
        let bamboos = [];
        let particles = [];
        let sliceEffects = [];

        // Èü≥Èüø„Ç®„Éï„Çß„ÇØ„ÉàÔºàWeb Audio API‰ΩøÁî®Ôºâ
        let audioContext;
        let masterGainNode;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGainNode = audioContext.createGain();
                masterGainNode.connect(audioContext.destination);
                masterGainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            } catch (e) {
                console.log('Web Audio API not supported');
            }
        }

        // ÂàáÊñ≠Èü≥„ÅÆÁîüÊàê
        function playSliceSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();
            
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(masterGainNode);
            
            // Èã≠„ÅÑÂàáÊñ≠Èü≥
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);
            
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(2000, audioContext.currentTime);
            filterNode.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.8, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }

        // „Ç≥„É≥„ÉúÈü≥„ÅÆÁîüÊàê
        function playComboSound(comboCount) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(masterGainNode);
            
            // „Ç≥„É≥„ÉúÊï∞„Å´Âøú„Åò„Å¶Èü≥Á®ã„Çí‰∏ä„Åí„Çã
            const frequency = 440 + (comboCount * 50);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        // Á´π„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇØ„É©„Çπ
        class Bamboo {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20 + Math.random() * 10;
                this.height = 100 + Math.random() * 50;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = Math.random() * -5 - 2;
                this.rotation = Math.random() * Math.PI * 2;
                this.angularVelocity = (Math.random() - 0.5) * 0.2;
                this.color = `hsl(${80 + Math.random() * 40}, 60%, 40%)`;
                this.segments = Math.floor(this.height / 15);
                this.isSliced = false;
                this.sliceY = 0;
                this.upperPart = null;
                this.lowerPart = null;
            }

            update() {
                if (!this.isSliced) {
                    this.vy += GRAVITY;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.rotation += this.angularVelocity;
                    
                    this.vx *= FRICTION;
                    this.vy *= FRICTION;

                    // ÁîªÈù¢Â§ñÂà§ÂÆö
                    if (this.y > canvas.height + 100) {
                        return false;
                    }
                } else {
                    // „Çπ„É©„Ç§„Çπ„Åï„Çå„ÅüÂæå„ÅÆÁâ©ÁêÜÊºîÁÆó
                    if (this.upperPart) {
                        this.upperPart.vy += GRAVITY;
                        this.upperPart.x += this.upperPart.vx;
                        this.upperPart.y += this.upperPart.vy;
                        this.upperPart.rotation += this.upperPart.angularVelocity;
                        this.upperPart.vx *= FRICTION;
                        this.upperPart.vy *= FRICTION;
                    }
                    
                    if (this.lowerPart) {
                        this.lowerPart.vy += GRAVITY;
                        this.lowerPart.x += this.lowerPart.vx;
                        this.lowerPart.y += this.lowerPart.vy;
                        this.lowerPart.rotation += this.lowerPart.angularVelocity;
                        this.lowerPart.vx *= FRICTION;
                        this.lowerPart.vy *= FRICTION;
                    }

                    // ÁîªÈù¢Â§ñÂà§ÂÆö
                    if (this.upperPart && this.upperPart.y > canvas.height + 100) {
                        this.upperPart = null;
                    }
                    if (this.lowerPart && this.lowerPart.y > canvas.height + 100) {
                        this.lowerPart = null;
                    }
                    
                    if (!this.upperPart && !this.lowerPart) {
                        return false;
                    }
                }
                
                return true;
            }

            slice(sliceY) {
                if (this.isSliced) return false;
                
                // Á´π„ÅÆÂ¢ÉÁïåÂÜÖ„Åß„ÅÆ„Çπ„É©„Ç§„ÇπÂà§ÂÆö
                const localSliceY = sliceY - this.y;
                if (localSliceY < 0 || localSliceY > this.height) return false;
                
                this.isSliced = true;
                this.sliceY = localSliceY;
                
                // ‰∏äÈÉ®„Å®‰∏ãÈÉ®„ÅÆ„Éë„Éº„ÉÑ„Çí‰ΩúÊàê
                this.upperPart = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.sliceY,
                    vx: this.vx + (Math.random() - 0.5) * 5,
                    vy: this.vy - Math.random() * 3,
                    rotation: this.rotation,
                    angularVelocity: (Math.random() - 0.5) * 0.3,
                    color: this.color
                };
                
                this.lowerPart = {
                    x: this.x,
                    y: this.y + this.sliceY,
                    width: this.width,
                    height: this.height - this.sliceY,
                    vx: this.vx + (Math.random() - 0.5) * 5,
                    vy: this.vy - Math.random() * 3,
                    rotation: this.rotation,
                    angularVelocity: (Math.random() - 0.5) * 0.3,
                    color: this.color
                };
                
                // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´ÂäπÊûú
                this.createSliceParticles(this.x, sliceY);
                
                return true;
            }

            createSliceParticles(x, y) {
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: x + (Math.random() - 0.5) * this.width,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        size: Math.random() * 4 + 2,
                        color: this.color,
                        life: 1.0,
                        decay: 0.02 + Math.random() * 0.02
                    });
                }
            }

            draw() {
                ctx.save();
                
                if (!this.isSliced) {
                    // ÈÄöÂ∏∏„ÅÆÁ´πÊèèÁîª
                    ctx.translate(this.x + this.width/2, this.y + this.height/2);
                    ctx.rotate(this.rotation);
                    
                    // Á´π„ÅÆÊú¨‰Ωì
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    
                    // Á´π„ÅÆÁØÄ
                    ctx.strokeStyle = '#228B22';
                    ctx.lineWidth = 2;
                    for (let i = 1; i < this.segments; i++) {
                        const segmentY = -this.height/2 + (this.height / this.segments) * i;
                        ctx.beginPath();
                        ctx.moveTo(-this.width/2, segmentY);
                        ctx.lineTo(this.width/2, segmentY);
                        ctx.stroke();
                    }
                    
                    // „Éè„Ç§„É©„Ç§„Éà
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.fillRect(-this.width/2, -this.height/2, this.width/3, this.height);
                    
                } else {
                    // „Çπ„É©„Ç§„Çπ„Åï„Çå„ÅüÁ´π„ÅÆÊèèÁîª
                    if (this.upperPart) {
                        this.drawBambooPart(this.upperPart);
                    }
                    if (this.lowerPart) {
                        this.drawBambooPart(this.lowerPart);
                    }
                }
                
                ctx.restore();
            }

            drawBambooPart(part) {
                ctx.save();
                ctx.translate(part.x + part.width/2, part.y + part.height/2);
                ctx.rotate(part.rotation);
                
                // Á´π„ÅÆÊú¨‰Ωì
                ctx.fillStyle = part.color;
                ctx.fillRect(-part.width/2, -part.height/2, part.width, part.height);
                
                // Á´π„ÅÆÁØÄ
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                const segments = Math.floor(part.height / 15);
                for (let i = 1; i < segments; i++) {
                    const segmentY = -part.height/2 + (part.height / segments) * i;
                    ctx.beginPath();
                    ctx.moveTo(-part.width/2, segmentY);
                    ctx.lineTo(part.width/2, segmentY);
                    ctx.stroke();
                }
                
                // „Éè„Ç§„É©„Ç§„Éà
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillRect(-part.width/2, -part.height/2, part.width/3, part.height);
                
                ctx.restore();
            }

            checkSlice(startX, startY, endX, endY) {
                if (this.isSliced) return false;
                
                // Á∑öÂàÜ„Å®Áü©ÂΩ¢„ÅÆ‰∫§Â∑ÆÂà§ÂÆö
                const bambooLeft = this.x;
                const bambooRight = this.x + this.width;
                const bambooTop = this.y;
                const bambooBottom = this.y + this.height;
                
                // „Çπ„É©„Ç§„ÇπÁ∑ö„Å®Á´π„ÅÆÂ¢ÉÁïå„Éú„ÉÉ„ÇØ„Çπ„ÅÆ‰∫§Â∑Æ„ÉÅ„Çß„ÉÉ„ÇØ
                if (this.lineIntersectsRect(startX, startY, endX, endY, 
                    bambooLeft, bambooTop, bambooRight, bambooBottom)) {
                    
                    // ‰∫§Â∑ÆÁÇπ„ÅÆYÂ∫ßÊ®ô„ÇíË®àÁÆó
                    const sliceY = this.getIntersectionY(startX, startY, endX, endY);
                    return this.slice(sliceY);
                }
                
                return false;
            }

            lineIntersectsRect(x1, y1, x2, y2, left, top, right, bottom) {
                // Á∑öÂàÜ„ÅÆ‰∏°Á´Ø„ÅåÁü©ÂΩ¢ÂÜÖ„Å´„ÅÇ„ÇãÂ†¥Âêà
                if ((x1 >= left && x1 <= right && y1 >= top && y1 <= bottom) ||
                    (x2 >= left && x2 <= right && y2 >= top && y2 <= bottom)) {
                    return true;
                }
                
                // Á∑öÂàÜ„Å®Áü©ÂΩ¢„ÅÆËæ∫„ÅÆ‰∫§Â∑ÆÂà§ÂÆö
                return this.lineIntersectsLine(x1, y1, x2, y2, left, top, right, top) ||    // ‰∏äËæ∫
                       this.lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom) || // Âè≥Ëæ∫
                       this.lineIntersectsLine(x1, y1, x2, y2, right, bottom, left, bottom) || // ‰∏ãËæ∫
                       this.lineIntersectsLine(x1, y1, x2, y2, left, bottom, left, top);     // Â∑¶Ëæ∫
            }

            lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (denom === 0) return false;
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                return t >= 0 && t <= 1 && u >= 0 && u <= 1;
            }

            getIntersectionY(startX, startY, endX, endY) {
                // Á´π„ÅÆ‰∏≠Â§Æ„Åß„ÅÆ„Çπ„É©„Ç§„ÇπYÂ∫ßÊ®ô„ÇíËøî„Åô
                return this.y + this.height / 2;
            }
        }

        // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êõ¥Êñ∞„Å®ÊèèÁîª
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += GRAVITY * 0.3;
                particle.vx *= 0.99;
                particle.vy *= 0.99;
                particle.life -= particle.decay;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // „Çπ„É©„Ç§„Çπ„Ç®„Éï„Çß„ÇØ„Éà
        function createSliceEffect(startX, startY, endX, endY) {
            const sliceDiv = document.createElement('div');
            sliceDiv.className = 'slice-effect slice-line';
            
            const length = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
            const angle = Math.atan2(endY - startY, endX - startX);
            
            sliceDiv.style.left = startX + 'px';
            sliceDiv.style.top = startY + 'px';
            sliceDiv.style.width = length + 'px';
            sliceDiv.style.height = '2px';
            sliceDiv.style.transform = `rotate(${angle}rad)`;
            sliceDiv.style.transformOrigin = '0 50%';
            
            document.body.appendChild(sliceDiv);
            
            setTimeout(() => {
                document.body.removeChild(sliceDiv);
            }, 300);
        }

        // Á´π„ÅÆÁîüÊàê
        function spawnBamboo() {
            if (!gameState.isPlaying) return;
            
            const x = Math.random() * (canvas.width - 50);
            const y = canvas.height + 50;
            bamboos.push(new Bamboo(x, y));
        }

        // „Çø„ÉÉ„ÉÅ„Éª„Éû„Ç¶„ÇπÂÖ•ÂäõÂá¶ÁêÜ
        let isSlicing = false;
        let sliceStart = { x: 0, y: 0 };
        let sliceEnd = { x: 0, y: 0 };
        let slicePath = [];

        function startSlice(x, y) {
            isSlicing = true;
            sliceStart = { x, y };
            sliceEnd = { x, y };
            slicePath = [{ x, y }];
        }

        function updateSlice(x, y) {
            if (!isSlicing) return;
            
            sliceEnd = { x, y };
            slicePath.push({ x, y });
            
            // „Çπ„É©„Ç§„ÇπËªåË∑°„ÅÆÂà∂ÈôêÔºà„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂêë‰∏äÔºâ
            if (slicePath.length > 10) {
                slicePath.shift();
            }
        }

        function endSlice() {
            if (!isSlicing) return;
            
            isSlicing = false;
            
            // „Çπ„É©„Ç§„Çπ„ÅÆÂÆüË°å
            let slicedCount = 0;
            const currentTime = Date.now();
            
            for (let i = bamboos.length - 1; i >= 0; i--) {
                const bamboo = bamboos[i];
                
                // „Çπ„É©„Ç§„ÇπËªåË∑°„ÅÆÂêÑ„Çª„Ç∞„É°„É≥„Éà„ÅßÂà§ÂÆö
                for (let j = 0; j < slicePath.length - 1; j++) {
                    const start = slicePath[j];
                    const end = slicePath[j + 1];
                    
                    if (bamboo.checkSlice(start.x, start.y, end.x, end.y)) {
                        slicedCount++;
                        break;
                    }
                }
            }
            
            if (slicedCount > 0) {
                // „Çπ„Ç≥„Ç¢Êõ¥Êñ∞
                gameState.score += slicedCount * 10;
                
                // „Ç≥„É≥„ÉúÂá¶ÁêÜ
                if (currentTime - gameState.lastCutTime < 1000) {
                    gameState.combo += slicedCount;
                    gameState.score += gameState.combo * 5; // „Ç≥„É≥„Éú„Éú„Éº„Éä„Çπ
                    playComboSound(gameState.combo);
                } else {
                    gameState.combo = slicedCount;
                }
                
                gameState.lastCutTime = currentTime;
                gameState.comboTimer = currentTime + 3000; // 3Áßí„Åß„Ç≥„É≥„Éú„É™„Çª„ÉÉ„Éà
                
                // „Çπ„É©„Ç§„Çπ„Ç®„Éï„Çß„ÇØ„Éà
                if (slicePath.length >= 2) {
                    createSliceEffect(slicePath[0].x, slicePath[0].y, 
                                    slicePath[slicePath.length-1].x, slicePath[slicePath.length-1].y);
                }
                
                // Èü≥Èüø„Ç®„Éï„Çß„ÇØ„Éà
                playSliceSound();
                
                // UIÊõ¥Êñ∞
                updateUI();
            }
            
            slicePath = [];
        }

        // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            startSlice(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            updateSlice(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mouseup', endSlice);

        // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            startSlice(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            updateSlice(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            endSlice();
        });

        // UIÊõ¥Êñ∞
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('combo').textContent = gameState.combo;
        }

        // „Çπ„É©„Ç§„ÇπËªåË∑°„ÅÆÊèèÁîª
        function drawSlicePath() {
            if (slicePath.length < 2) return;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 5;
            
            ctx.beginPath();
            ctx.moveTo(slicePath[0].x, slicePath[0].y);
            
            for (let i = 1; i < slicePath.length; i++) {
                ctx.lineTo(slicePath[i].x, slicePath[i].y);
            }
            
            ctx.stroke();
            ctx.restore();
        }

        // „É°„Ç§„É≥„Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            // ËÉåÊôØ„ÇØ„É™„Ç¢
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.isPlaying) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // „Ç≥„É≥„Éú„Çø„Ç§„Éû„ÉºÁÆ°ÁêÜ
            if (Date.now() > gameState.comboTimer) {
                gameState.combo = 0;
                updateUI();
            }
            
            // Á´π„ÅÆÊõ¥Êñ∞„Å®ÊèèÁîª
            for (let i = bamboos.length - 1; i >= 0; i--) {
                if (!bamboos[i].update()) {
                    bamboos.splice(i, 1);
                }
            }
            
            for (const bamboo of bamboos) {
                bamboo.draw();
            }
            
            // „Éë„Éº„ÉÜ„Ç£„ÇØ„É´Êõ¥Êñ∞
            updateParticles();
            
            // „Çπ„É©„Ç§„ÇπËªåË∑°ÊèèÁîª
            drawSlicePath();
            
            requestAnimationFrame(gameLoop);
        }

        // „Ç≤„Éº„É†ÈñãÂßã
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.combo = 0;
            gameState.lastCutTime = 0;
            
            initAudio();
            updateUI();
            
            // Á´π„ÅÆÂÆöÊúüÁîüÊàê
            setInterval(() => {
                if (gameState.isPlaying && Math.random() < 0.7) {
                    spawnBamboo();
                }
            }, 1500);
        }

        // PWA „Éû„Éã„Éï„Çß„Çπ„ÉàÂãïÁöÑÁîüÊàê
        function generateManifest() {
            const manifest = {
                name: "Á´πÂàá„Çä„Ç≤„Éº„É† - ÁàΩÂø´Êñ¨ÊíÉ‰ΩìÈ®ì",
                short_name: "Á´πÂàá„Çä",
                description: "„É™„Ç¢„É´„Å™Áâ©ÁêÜÊºîÁÆó„ÅßÁ´π„Çí„Çπ„Éë„ÉÉ„Å®Âàá„ÇãÁàΩÂø´„Ç≤„Éº„É†",
                start_url: "./index.html",
                display: "standalone",
                background_color: "#2E7D32",
                theme_color: "#2E7D32",
                orientation: "any",
                icons: [
                    {
                        src: "data:image/svg+xml;base64," + btoa(`
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 192">
                                <rect fill="#2E7D32" width="192" height="192"/>
                                <rect fill="#4CAF50" x="60" y="20" width="20" height="152" rx="10"/>
                                <rect fill="#66BB6A" x="80" y="30" width="20" height="132" rx="10"/>
                                <rect fill="#4CAF50" x="100" y="25" width="20" height="142" rx="10"/>
                                <path fill="#FFEB3B" d="M50 80 L140 60 L145 65 L55 85 Z"/>
                                <text x="96" y="185" font-family="sans-serif" font-size="20" text-anchor="middle" fill="white">üéã</text>
                            </svg>
                        `),
                        sizes: "192x192",
                        type: "image/svg+xml"
                    }
                ]
            };
            
            const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
            const manifestURL = URL.createObjectURL(blob);
            document.getElementById('manifest-placeholder').href = manifestURL;
        }

        // ÂàùÊúüÂåñ
        generateManifest();
        gameLoop();
    </script>
</body>
</html>